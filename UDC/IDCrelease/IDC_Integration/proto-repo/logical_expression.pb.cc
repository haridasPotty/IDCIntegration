// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: logical_expression.proto

#include "logical_expression.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
extern PROTOBUF_INTERNAL_EXPORT_logical_5fexpression_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_ComparisonExpression_logical_5fexpression_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_logical_5fexpression_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_LogicalOperand_logical_5fexpression_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_logical_5fexpression_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<8> scc_info_Operand_logical_5fexpression_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_logical_5fexpression_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_Operation_logical_5fexpression_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_logical_5fexpression_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_TransitionExpression_logical_5fexpression_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_signal_5fsource_5fdefinition_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_CanSource_signal_5fsource_5fdefinition_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_signal_5fsource_5fdefinition_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_DefaultSource_signal_5fsource_5fdefinition_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_signal_5fsource_5fdefinition_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_EthernetSource_signal_5fsource_5fdefinition_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_signal_5fsource_5fdefinition_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_InternalSource_signal_5fsource_5fdefinition_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_signal_5fsource_5fdefinition_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_LinSource_signal_5fsource_5fdefinition_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_signal_5fsource_5fdefinition_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<4> scc_info_NetworkSource_signal_5fsource_5fdefinition_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_signal_5fsource_5fdefinition_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_ProcessingToolboxSource_signal_5fsource_5fdefinition_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_signal_5fsource_5fdefinition_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_ThriftmeSource_signal_5fsource_5fdefinition_2eproto;
namespace logical_expression {
class LogicalExpressionDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<LogicalExpression> _instance;
} _LogicalExpression_default_instance_;
class LogicalOperandDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<LogicalOperand> _instance;
  const ::logical_expression::ComparisonExpression* comparison_expression_;
  const ::logical_expression::TransitionExpression* transition_expression_;
} _LogicalOperand_default_instance_;
class OperandDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Operand> _instance;
  ::PROTOBUF_NAMESPACE_ID::int64 int64_value_;
  bool bool_value_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr string_value_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bytes_value_;
  const ::signal_source_definition::DefaultSource* default_signal_;
  const ::signal_source_definition::CanSource* can_signal_;
  const ::signal_source_definition::LinSource* lin_signal_;
  const ::signal_source_definition::EthernetSource* ethernet_signal_;
  const ::signal_source_definition::NetworkSource* network_signal_;
  const ::signal_source_definition::InternalSource* internal_signal_;
  const ::signal_source_definition::ProcessingToolboxSource* processing_toolbox_signal_;
  const ::signal_source_definition::ThriftmeSource* thriftme_signal_;
} _Operand_default_instance_;
class ComparisonExpressionDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<ComparisonExpression> _instance;
} _ComparisonExpression_default_instance_;
class OperationDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Operation> _instance;
} _Operation_default_instance_;
class TransitionExpressionDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<TransitionExpression> _instance;
} _TransitionExpression_default_instance_;
}  // namespace logical_expression
static void InitDefaultsscc_info_ComparisonExpression_logical_5fexpression_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::logical_expression::_ComparisonExpression_default_instance_;
    new (ptr) ::logical_expression::ComparisonExpression();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::logical_expression::ComparisonExpression::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_ComparisonExpression_logical_5fexpression_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_ComparisonExpression_logical_5fexpression_2eproto}, {
      &scc_info_Operation_logical_5fexpression_2eproto.base,}};

static void InitDefaultsscc_info_LogicalExpression_logical_5fexpression_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::logical_expression::_LogicalExpression_default_instance_;
    new (ptr) ::logical_expression::LogicalExpression();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::logical_expression::LogicalExpression::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_LogicalExpression_logical_5fexpression_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_LogicalExpression_logical_5fexpression_2eproto}, {
      &scc_info_LogicalOperand_logical_5fexpression_2eproto.base,}};

static void InitDefaultsscc_info_LogicalOperand_logical_5fexpression_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::logical_expression::_LogicalOperand_default_instance_;
    new (ptr) ::logical_expression::LogicalOperand();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::logical_expression::LogicalOperand::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_LogicalOperand_logical_5fexpression_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 2, 0, InitDefaultsscc_info_LogicalOperand_logical_5fexpression_2eproto}, {
      &scc_info_ComparisonExpression_logical_5fexpression_2eproto.base,
      &scc_info_TransitionExpression_logical_5fexpression_2eproto.base,}};

static void InitDefaultsscc_info_Operand_logical_5fexpression_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::logical_expression::_Operand_default_instance_;
    new (ptr) ::logical_expression::Operand();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::logical_expression::Operand::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<8> scc_info_Operand_logical_5fexpression_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 8, 0, InitDefaultsscc_info_Operand_logical_5fexpression_2eproto}, {
      &scc_info_DefaultSource_signal_5fsource_5fdefinition_2eproto.base,
      &scc_info_CanSource_signal_5fsource_5fdefinition_2eproto.base,
      &scc_info_LinSource_signal_5fsource_5fdefinition_2eproto.base,
      &scc_info_EthernetSource_signal_5fsource_5fdefinition_2eproto.base,
      &scc_info_NetworkSource_signal_5fsource_5fdefinition_2eproto.base,
      &scc_info_InternalSource_signal_5fsource_5fdefinition_2eproto.base,
      &scc_info_ProcessingToolboxSource_signal_5fsource_5fdefinition_2eproto.base,
      &scc_info_ThriftmeSource_signal_5fsource_5fdefinition_2eproto.base,}};

static void InitDefaultsscc_info_Operation_logical_5fexpression_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::logical_expression::_Operation_default_instance_;
    new (ptr) ::logical_expression::Operation();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::logical_expression::Operation::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_Operation_logical_5fexpression_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_Operation_logical_5fexpression_2eproto}, {
      &scc_info_Operand_logical_5fexpression_2eproto.base,}};

static void InitDefaultsscc_info_TransitionExpression_logical_5fexpression_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::logical_expression::_TransitionExpression_default_instance_;
    new (ptr) ::logical_expression::TransitionExpression();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::logical_expression::TransitionExpression::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_TransitionExpression_logical_5fexpression_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_TransitionExpression_logical_5fexpression_2eproto}, {
      &scc_info_Operand_logical_5fexpression_2eproto.base,}};

static ::PROTOBUF_NAMESPACE_ID::Metadata file_level_metadata_logical_5fexpression_2eproto[6];
static const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* file_level_enum_descriptors_logical_5fexpression_2eproto[3];
static constexpr ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor const** file_level_service_descriptors_logical_5fexpression_2eproto = nullptr;

const ::PROTOBUF_NAMESPACE_ID::uint32 TableStruct_logical_5fexpression_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::logical_expression::LogicalExpression, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::logical_expression::LogicalExpression, not__),
  PROTOBUF_FIELD_OFFSET(::logical_expression::LogicalExpression, operator__),
  PROTOBUF_FIELD_OFFSET(::logical_expression::LogicalExpression, operand_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::logical_expression::LogicalOperand, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::logical_expression::LogicalOperand, _oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::logical_expression::LogicalOperand, not__),
  offsetof(::logical_expression::LogicalOperandDefaultTypeInternal, comparison_expression_),
  offsetof(::logical_expression::LogicalOperandDefaultTypeInternal, transition_expression_),
  PROTOBUF_FIELD_OFFSET(::logical_expression::LogicalOperand, expression_function_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::logical_expression::Operand, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::logical_expression::Operand, _oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  offsetof(::logical_expression::OperandDefaultTypeInternal, int64_value_),
  offsetof(::logical_expression::OperandDefaultTypeInternal, bool_value_),
  offsetof(::logical_expression::OperandDefaultTypeInternal, string_value_),
  offsetof(::logical_expression::OperandDefaultTypeInternal, bytes_value_),
  offsetof(::logical_expression::OperandDefaultTypeInternal, default_signal_),
  offsetof(::logical_expression::OperandDefaultTypeInternal, can_signal_),
  offsetof(::logical_expression::OperandDefaultTypeInternal, lin_signal_),
  offsetof(::logical_expression::OperandDefaultTypeInternal, ethernet_signal_),
  offsetof(::logical_expression::OperandDefaultTypeInternal, network_signal_),
  offsetof(::logical_expression::OperandDefaultTypeInternal, internal_signal_),
  offsetof(::logical_expression::OperandDefaultTypeInternal, processing_toolbox_signal_),
  offsetof(::logical_expression::OperandDefaultTypeInternal, thriftme_signal_),
  PROTOBUF_FIELD_OFFSET(::logical_expression::Operand, operand_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::logical_expression::ComparisonExpression, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::logical_expression::ComparisonExpression, not__),
  PROTOBUF_FIELD_OFFSET(::logical_expression::ComparisonExpression, first_operation_),
  PROTOBUF_FIELD_OFFSET(::logical_expression::ComparisonExpression, operator__),
  PROTOBUF_FIELD_OFFSET(::logical_expression::ComparisonExpression, second_operation_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::logical_expression::Operation, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::logical_expression::Operation, first_operand_),
  PROTOBUF_FIELD_OFFSET(::logical_expression::Operation, operator__),
  PROTOBUF_FIELD_OFFSET(::logical_expression::Operation, second_operand_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::logical_expression::TransitionExpression, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::logical_expression::TransitionExpression, signal_identifier_),
  PROTOBUF_FIELD_OFFSET(::logical_expression::TransitionExpression, from_operator_),
  PROTOBUF_FIELD_OFFSET(::logical_expression::TransitionExpression, from_value_),
  PROTOBUF_FIELD_OFFSET(::logical_expression::TransitionExpression, to_operator_),
  PROTOBUF_FIELD_OFFSET(::logical_expression::TransitionExpression, to_value_),
};
static const ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, sizeof(::logical_expression::LogicalExpression)},
  { 8, -1, sizeof(::logical_expression::LogicalOperand)},
  { 17, -1, sizeof(::logical_expression::Operand)},
  { 35, -1, sizeof(::logical_expression::ComparisonExpression)},
  { 44, -1, sizeof(::logical_expression::Operation)},
  { 52, -1, sizeof(::logical_expression::TransitionExpression)},
};

static ::PROTOBUF_NAMESPACE_ID::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::logical_expression::_LogicalExpression_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::logical_expression::_LogicalOperand_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::logical_expression::_Operand_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::logical_expression::_ComparisonExpression_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::logical_expression::_Operation_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::logical_expression::_TransitionExpression_default_instance_),
};

const char descriptor_table_protodef_logical_5fexpression_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\030logical_expression.proto\022\022logical_expr"
  "ession\032\036signal_source_definition.proto\"\214"
  "\001\n\021LogicalExpression\022\013\n\003not\030\001 \001(\010\0225\n\010ope"
  "rator\030\002 \001(\0162#.logical_expression.Logical"
  "Operator\0223\n\007operand\030\003 \003(\0132\".logical_expr"
  "ession.LogicalOperand\"\312\001\n\016LogicalOperand"
  "\022\013\n\003not\030\001 \001(\010\022I\n\025comparison_expression\030\002"
  " \001(\0132(.logical_expression.ComparisonExpr"
  "essionH\000\022I\n\025transition_expression\030\003 \001(\0132"
  "(.logical_expression.TransitionExpressio"
  "nH\000B\025\n\023expression_function\"\223\005\n\007Operand\022\025"
  "\n\013int64_value\030\001 \001(\003H\000\022\024\n\nbool_value\030\002 \001("
  "\010H\000\022\026\n\014string_value\030\003 \001(\tH\000\022\025\n\013bytes_val"
  "ue\030\004 \001(\014H\000\022A\n\016default_signal\030\005 \001(\0132\'.sig"
  "nal_source_definition.DefaultSourceH\000\0229\n"
  "\ncan_signal\030\006 \001(\0132#.signal_source_defini"
  "tion.CanSourceH\000\0229\n\nlin_signal\030\007 \001(\0132#.s"
  "ignal_source_definition.LinSourceH\000\022C\n\017e"
  "thernet_signal\030\010 \001(\0132(.signal_source_def"
  "inition.EthernetSourceH\000\022A\n\016network_sign"
  "al\030\t \001(\0132\'.signal_source_definition.Netw"
  "orkSourceH\000\022C\n\017internal_signal\030\n \001(\0132(.s"
  "ignal_source_definition.InternalSourceH\000"
  "\022V\n\031processing_toolbox_signal\030\013 \001(\01321.si"
  "gnal_source_definition.ProcessingToolbox"
  "SourceH\000\022C\n\017thriftme_signal\030\014 \001(\0132(.sign"
  "al_source_definition.ThriftmeSourceH\000B\t\n"
  "\007operand\"\322\001\n\024ComparisonExpression\022\013\n\003not"
  "\030\001 \001(\010\0226\n\017first_operation\030\002 \001(\0132\035.logica"
  "l_expression.Operation\022<\n\010operator\030\003 \001(\016"
  "2*.logical_expression.ComparisonOperator"
  "Type\0227\n\020second_operation\030\004 \001(\0132\035.logical"
  "_expression.Operation\"\251\001\n\tOperation\0222\n\rf"
  "irst_operand\030\001 \001(\0132\033.logical_expression."
  "Operand\0223\n\010operator\030\002 \001(\0162!.logical_expr"
  "ession.OperationType\0223\n\016second_operand\030\003"
  " \001(\0132\033.logical_expression.Operand\"\262\002\n\024Tr"
  "ansitionExpression\0226\n\021signal_identifier\030"
  "\001 \001(\0132\033.logical_expression.Operand\022A\n\rfr"
  "om_operator\030\002 \001(\0162*.logical_expression.C"
  "omparisonOperatorType\022/\n\nfrom_value\030\003 \001("
  "\0132\033.logical_expression.Operand\022\?\n\013to_ope"
  "rator\030\004 \001(\0162*.logical_expression.Compari"
  "sonOperatorType\022-\n\010to_value\030\005 \001(\0132\033.logi"
  "cal_expression.Operand*@\n\017LogicalOperato"
  "r\022\034\n\030UNKNOWN_LOGICAL_OPERATOR\020\000\022\007\n\003AND\020\001"
  "\022\006\n\002OR\020\002*y\n\rOperationType\022\032\n\026UNKNOWN_OPE"
  "RATION_TYPE\020\000\022\020\n\014NO_OPERATION\020\001\022\007\n\003SUM\020\002"
  "\022\017\n\013SUBTRACTION\020\003\022\022\n\016MULTIPLICATION\020\004\022\014\n"
  "\010DIVISION\020\005*\230\001\n\026ComparisonOperatorType\022$"
  "\n UNKNOWN_COMPARISON_OPERATOR_TYPE\020\000\022\t\n\005"
  "EQUAL\020\001\022\r\n\tNOT_EQUAL\020\002\022\013\n\007GREATER\020\003\022\010\n\004L"
  "ESS\020\004\022\024\n\020GREATER_OR_EQUAL\020\005\022\021\n\rLESS_OR_E"
  "QUAL\020\006b\006proto3"
  ;
static const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable*const descriptor_table_logical_5fexpression_2eproto_deps[1] = {
  &::descriptor_table_signal_5fsource_5fdefinition_2eproto,
};
static ::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase*const descriptor_table_logical_5fexpression_2eproto_sccs[6] = {
  &scc_info_ComparisonExpression_logical_5fexpression_2eproto.base,
  &scc_info_LogicalExpression_logical_5fexpression_2eproto.base,
  &scc_info_LogicalOperand_logical_5fexpression_2eproto.base,
  &scc_info_Operand_logical_5fexpression_2eproto.base,
  &scc_info_Operation_logical_5fexpression_2eproto.base,
  &scc_info_TransitionExpression_logical_5fexpression_2eproto.base,
};
static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_logical_5fexpression_2eproto_once;
static bool descriptor_table_logical_5fexpression_2eproto_initialized = false;
const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_logical_5fexpression_2eproto = {
  &descriptor_table_logical_5fexpression_2eproto_initialized, descriptor_table_protodef_logical_5fexpression_2eproto, "logical_expression.proto", 2134,
  &descriptor_table_logical_5fexpression_2eproto_once, descriptor_table_logical_5fexpression_2eproto_sccs, descriptor_table_logical_5fexpression_2eproto_deps, 6, 1,
  schemas, file_default_instances, TableStruct_logical_5fexpression_2eproto::offsets,
  file_level_metadata_logical_5fexpression_2eproto, 6, file_level_enum_descriptors_logical_5fexpression_2eproto, file_level_service_descriptors_logical_5fexpression_2eproto,
};

// Force running AddDescriptors() at dynamic initialization time.
static bool dynamic_init_dummy_logical_5fexpression_2eproto = (  ::PROTOBUF_NAMESPACE_ID::internal::AddDescriptors(&descriptor_table_logical_5fexpression_2eproto), true);
namespace logical_expression {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LogicalOperator_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_logical_5fexpression_2eproto);
  return file_level_enum_descriptors_logical_5fexpression_2eproto[0];
}
bool LogicalOperator_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* OperationType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_logical_5fexpression_2eproto);
  return file_level_enum_descriptors_logical_5fexpression_2eproto[1];
}
bool OperationType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ComparisonOperatorType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_logical_5fexpression_2eproto);
  return file_level_enum_descriptors_logical_5fexpression_2eproto[2];
}
bool ComparisonOperatorType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}


// ===================================================================

void LogicalExpression::InitAsDefaultInstance() {
}
class LogicalExpression::_Internal {
 public:
};

LogicalExpression::LogicalExpression()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:logical_expression.LogicalExpression)
}
LogicalExpression::LogicalExpression(const LogicalExpression& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      operand_(from.operand_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&not__, &from.not__,
    static_cast<size_t>(reinterpret_cast<char*>(&operator__) -
    reinterpret_cast<char*>(&not__)) + sizeof(operator__));
  // @@protoc_insertion_point(copy_constructor:logical_expression.LogicalExpression)
}

void LogicalExpression::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_LogicalExpression_logical_5fexpression_2eproto.base);
  ::memset(&not__, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&operator__) -
      reinterpret_cast<char*>(&not__)) + sizeof(operator__));
}

LogicalExpression::~LogicalExpression() {
  // @@protoc_insertion_point(destructor:logical_expression.LogicalExpression)
  SharedDtor();
}

void LogicalExpression::SharedDtor() {
}

void LogicalExpression::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const LogicalExpression& LogicalExpression::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_LogicalExpression_logical_5fexpression_2eproto.base);
  return *internal_default_instance();
}


void LogicalExpression::Clear() {
// @@protoc_insertion_point(message_clear_start:logical_expression.LogicalExpression)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  operand_.Clear();
  ::memset(&not__, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&operator__) -
      reinterpret_cast<char*>(&not__)) + sizeof(operator__));
  _internal_metadata_.Clear();
}

const char* LogicalExpression::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // bool not = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          not__ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .logical_expression.LogicalOperator operator = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          _internal_set_operator_(static_cast<::logical_expression::LogicalOperator>(val));
        } else goto handle_unusual;
        continue;
      // repeated .logical_expression.LogicalOperand operand = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_operand(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* LogicalExpression::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:logical_expression.LogicalExpression)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // bool not = 1;
  if (this->not_() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(1, this->_internal_not_(), target);
  }

  // .logical_expression.LogicalOperator operator = 2;
  if (this->operator_() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_operator_(), target);
  }

  // repeated .logical_expression.LogicalOperand operand = 3;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_operand_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, this->_internal_operand(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:logical_expression.LogicalExpression)
  return target;
}

size_t LogicalExpression::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:logical_expression.LogicalExpression)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .logical_expression.LogicalOperand operand = 3;
  total_size += 1UL * this->_internal_operand_size();
  for (const auto& msg : this->operand_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // bool not = 1;
  if (this->not_() != 0) {
    total_size += 1 + 1;
  }

  // .logical_expression.LogicalOperator operator = 2;
  if (this->operator_() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_operator_());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void LogicalExpression::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:logical_expression.LogicalExpression)
  GOOGLE_DCHECK_NE(&from, this);
  const LogicalExpression* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<LogicalExpression>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:logical_expression.LogicalExpression)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:logical_expression.LogicalExpression)
    MergeFrom(*source);
  }
}

void LogicalExpression::MergeFrom(const LogicalExpression& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:logical_expression.LogicalExpression)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  operand_.MergeFrom(from.operand_);
  if (from.not_() != 0) {
    _internal_set_not_(from._internal_not_());
  }
  if (from.operator_() != 0) {
    _internal_set_operator_(from._internal_operator_());
  }
}

void LogicalExpression::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:logical_expression.LogicalExpression)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void LogicalExpression::CopyFrom(const LogicalExpression& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:logical_expression.LogicalExpression)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LogicalExpression::IsInitialized() const {
  return true;
}

void LogicalExpression::InternalSwap(LogicalExpression* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  operand_.InternalSwap(&other->operand_);
  swap(not__, other->not__);
  swap(operator__, other->operator__);
}

::PROTOBUF_NAMESPACE_ID::Metadata LogicalExpression::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void LogicalOperand::InitAsDefaultInstance() {
  ::logical_expression::_LogicalOperand_default_instance_.comparison_expression_ = const_cast< ::logical_expression::ComparisonExpression*>(
      ::logical_expression::ComparisonExpression::internal_default_instance());
  ::logical_expression::_LogicalOperand_default_instance_.transition_expression_ = const_cast< ::logical_expression::TransitionExpression*>(
      ::logical_expression::TransitionExpression::internal_default_instance());
}
class LogicalOperand::_Internal {
 public:
  static const ::logical_expression::ComparisonExpression& comparison_expression(const LogicalOperand* msg);
  static const ::logical_expression::TransitionExpression& transition_expression(const LogicalOperand* msg);
};

const ::logical_expression::ComparisonExpression&
LogicalOperand::_Internal::comparison_expression(const LogicalOperand* msg) {
  return *msg->expression_function_.comparison_expression_;
}
const ::logical_expression::TransitionExpression&
LogicalOperand::_Internal::transition_expression(const LogicalOperand* msg) {
  return *msg->expression_function_.transition_expression_;
}
void LogicalOperand::set_allocated_comparison_expression(::logical_expression::ComparisonExpression* comparison_expression) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  clear_expression_function();
  if (comparison_expression) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      comparison_expression = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, comparison_expression, submessage_arena);
    }
    set_has_comparison_expression();
    expression_function_.comparison_expression_ = comparison_expression;
  }
  // @@protoc_insertion_point(field_set_allocated:logical_expression.LogicalOperand.comparison_expression)
}
void LogicalOperand::set_allocated_transition_expression(::logical_expression::TransitionExpression* transition_expression) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  clear_expression_function();
  if (transition_expression) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      transition_expression = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, transition_expression, submessage_arena);
    }
    set_has_transition_expression();
    expression_function_.transition_expression_ = transition_expression;
  }
  // @@protoc_insertion_point(field_set_allocated:logical_expression.LogicalOperand.transition_expression)
}
LogicalOperand::LogicalOperand()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:logical_expression.LogicalOperand)
}
LogicalOperand::LogicalOperand(const LogicalOperand& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  not__ = from.not__;
  clear_has_expression_function();
  switch (from.expression_function_case()) {
    case kComparisonExpression: {
      _internal_mutable_comparison_expression()->::logical_expression::ComparisonExpression::MergeFrom(from._internal_comparison_expression());
      break;
    }
    case kTransitionExpression: {
      _internal_mutable_transition_expression()->::logical_expression::TransitionExpression::MergeFrom(from._internal_transition_expression());
      break;
    }
    case EXPRESSION_FUNCTION_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:logical_expression.LogicalOperand)
}

void LogicalOperand::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_LogicalOperand_logical_5fexpression_2eproto.base);
  not__ = false;
  clear_has_expression_function();
}

LogicalOperand::~LogicalOperand() {
  // @@protoc_insertion_point(destructor:logical_expression.LogicalOperand)
  SharedDtor();
}

void LogicalOperand::SharedDtor() {
  if (has_expression_function()) {
    clear_expression_function();
  }
}

void LogicalOperand::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const LogicalOperand& LogicalOperand::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_LogicalOperand_logical_5fexpression_2eproto.base);
  return *internal_default_instance();
}


void LogicalOperand::clear_expression_function() {
// @@protoc_insertion_point(one_of_clear_start:logical_expression.LogicalOperand)
  switch (expression_function_case()) {
    case kComparisonExpression: {
      delete expression_function_.comparison_expression_;
      break;
    }
    case kTransitionExpression: {
      delete expression_function_.transition_expression_;
      break;
    }
    case EXPRESSION_FUNCTION_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = EXPRESSION_FUNCTION_NOT_SET;
}


void LogicalOperand::Clear() {
// @@protoc_insertion_point(message_clear_start:logical_expression.LogicalOperand)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  not__ = false;
  clear_expression_function();
  _internal_metadata_.Clear();
}

const char* LogicalOperand::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // bool not = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          not__ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .logical_expression.ComparisonExpression comparison_expression = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_comparison_expression(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .logical_expression.TransitionExpression transition_expression = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_transition_expression(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* LogicalOperand::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:logical_expression.LogicalOperand)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // bool not = 1;
  if (this->not_() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(1, this->_internal_not_(), target);
  }

  // .logical_expression.ComparisonExpression comparison_expression = 2;
  if (_internal_has_comparison_expression()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::comparison_expression(this), target, stream);
  }

  // .logical_expression.TransitionExpression transition_expression = 3;
  if (_internal_has_transition_expression()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::transition_expression(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:logical_expression.LogicalOperand)
  return target;
}

size_t LogicalOperand::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:logical_expression.LogicalOperand)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bool not = 1;
  if (this->not_() != 0) {
    total_size += 1 + 1;
  }

  switch (expression_function_case()) {
    // .logical_expression.ComparisonExpression comparison_expression = 2;
    case kComparisonExpression: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *expression_function_.comparison_expression_);
      break;
    }
    // .logical_expression.TransitionExpression transition_expression = 3;
    case kTransitionExpression: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *expression_function_.transition_expression_);
      break;
    }
    case EXPRESSION_FUNCTION_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void LogicalOperand::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:logical_expression.LogicalOperand)
  GOOGLE_DCHECK_NE(&from, this);
  const LogicalOperand* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<LogicalOperand>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:logical_expression.LogicalOperand)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:logical_expression.LogicalOperand)
    MergeFrom(*source);
  }
}

void LogicalOperand::MergeFrom(const LogicalOperand& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:logical_expression.LogicalOperand)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.not_() != 0) {
    _internal_set_not_(from._internal_not_());
  }
  switch (from.expression_function_case()) {
    case kComparisonExpression: {
      _internal_mutable_comparison_expression()->::logical_expression::ComparisonExpression::MergeFrom(from._internal_comparison_expression());
      break;
    }
    case kTransitionExpression: {
      _internal_mutable_transition_expression()->::logical_expression::TransitionExpression::MergeFrom(from._internal_transition_expression());
      break;
    }
    case EXPRESSION_FUNCTION_NOT_SET: {
      break;
    }
  }
}

void LogicalOperand::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:logical_expression.LogicalOperand)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void LogicalOperand::CopyFrom(const LogicalOperand& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:logical_expression.LogicalOperand)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LogicalOperand::IsInitialized() const {
  return true;
}

void LogicalOperand::InternalSwap(LogicalOperand* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(not__, other->not__);
  swap(expression_function_, other->expression_function_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata LogicalOperand::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void Operand::InitAsDefaultInstance() {
  ::logical_expression::_Operand_default_instance_.int64_value_ = PROTOBUF_LONGLONG(0);
  ::logical_expression::_Operand_default_instance_.bool_value_ = false;
  ::logical_expression::_Operand_default_instance_.string_value_.UnsafeSetDefault(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::logical_expression::_Operand_default_instance_.bytes_value_.UnsafeSetDefault(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::logical_expression::_Operand_default_instance_.default_signal_ = const_cast< ::signal_source_definition::DefaultSource*>(
      ::signal_source_definition::DefaultSource::internal_default_instance());
  ::logical_expression::_Operand_default_instance_.can_signal_ = const_cast< ::signal_source_definition::CanSource*>(
      ::signal_source_definition::CanSource::internal_default_instance());
  ::logical_expression::_Operand_default_instance_.lin_signal_ = const_cast< ::signal_source_definition::LinSource*>(
      ::signal_source_definition::LinSource::internal_default_instance());
  ::logical_expression::_Operand_default_instance_.ethernet_signal_ = const_cast< ::signal_source_definition::EthernetSource*>(
      ::signal_source_definition::EthernetSource::internal_default_instance());
  ::logical_expression::_Operand_default_instance_.network_signal_ = const_cast< ::signal_source_definition::NetworkSource*>(
      ::signal_source_definition::NetworkSource::internal_default_instance());
  ::logical_expression::_Operand_default_instance_.internal_signal_ = const_cast< ::signal_source_definition::InternalSource*>(
      ::signal_source_definition::InternalSource::internal_default_instance());
  ::logical_expression::_Operand_default_instance_.processing_toolbox_signal_ = const_cast< ::signal_source_definition::ProcessingToolboxSource*>(
      ::signal_source_definition::ProcessingToolboxSource::internal_default_instance());
  ::logical_expression::_Operand_default_instance_.thriftme_signal_ = const_cast< ::signal_source_definition::ThriftmeSource*>(
      ::signal_source_definition::ThriftmeSource::internal_default_instance());
}
class Operand::_Internal {
 public:
  static const ::signal_source_definition::DefaultSource& default_signal(const Operand* msg);
  static const ::signal_source_definition::CanSource& can_signal(const Operand* msg);
  static const ::signal_source_definition::LinSource& lin_signal(const Operand* msg);
  static const ::signal_source_definition::EthernetSource& ethernet_signal(const Operand* msg);
  static const ::signal_source_definition::NetworkSource& network_signal(const Operand* msg);
  static const ::signal_source_definition::InternalSource& internal_signal(const Operand* msg);
  static const ::signal_source_definition::ProcessingToolboxSource& processing_toolbox_signal(const Operand* msg);
  static const ::signal_source_definition::ThriftmeSource& thriftme_signal(const Operand* msg);
};

const ::signal_source_definition::DefaultSource&
Operand::_Internal::default_signal(const Operand* msg) {
  return *msg->operand_.default_signal_;
}
const ::signal_source_definition::CanSource&
Operand::_Internal::can_signal(const Operand* msg) {
  return *msg->operand_.can_signal_;
}
const ::signal_source_definition::LinSource&
Operand::_Internal::lin_signal(const Operand* msg) {
  return *msg->operand_.lin_signal_;
}
const ::signal_source_definition::EthernetSource&
Operand::_Internal::ethernet_signal(const Operand* msg) {
  return *msg->operand_.ethernet_signal_;
}
const ::signal_source_definition::NetworkSource&
Operand::_Internal::network_signal(const Operand* msg) {
  return *msg->operand_.network_signal_;
}
const ::signal_source_definition::InternalSource&
Operand::_Internal::internal_signal(const Operand* msg) {
  return *msg->operand_.internal_signal_;
}
const ::signal_source_definition::ProcessingToolboxSource&
Operand::_Internal::processing_toolbox_signal(const Operand* msg) {
  return *msg->operand_.processing_toolbox_signal_;
}
const ::signal_source_definition::ThriftmeSource&
Operand::_Internal::thriftme_signal(const Operand* msg) {
  return *msg->operand_.thriftme_signal_;
}
void Operand::set_allocated_default_signal(::signal_source_definition::DefaultSource* default_signal) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  clear_operand();
  if (default_signal) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      default_signal = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, default_signal, submessage_arena);
    }
    set_has_default_signal();
    operand_.default_signal_ = default_signal;
  }
  // @@protoc_insertion_point(field_set_allocated:logical_expression.Operand.default_signal)
}
void Operand::clear_default_signal() {
  if (_internal_has_default_signal()) {
    delete operand_.default_signal_;
    clear_has_operand();
  }
}
void Operand::set_allocated_can_signal(::signal_source_definition::CanSource* can_signal) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  clear_operand();
  if (can_signal) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      can_signal = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, can_signal, submessage_arena);
    }
    set_has_can_signal();
    operand_.can_signal_ = can_signal;
  }
  // @@protoc_insertion_point(field_set_allocated:logical_expression.Operand.can_signal)
}
void Operand::clear_can_signal() {
  if (_internal_has_can_signal()) {
    delete operand_.can_signal_;
    clear_has_operand();
  }
}
void Operand::set_allocated_lin_signal(::signal_source_definition::LinSource* lin_signal) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  clear_operand();
  if (lin_signal) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      lin_signal = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lin_signal, submessage_arena);
    }
    set_has_lin_signal();
    operand_.lin_signal_ = lin_signal;
  }
  // @@protoc_insertion_point(field_set_allocated:logical_expression.Operand.lin_signal)
}
void Operand::clear_lin_signal() {
  if (_internal_has_lin_signal()) {
    delete operand_.lin_signal_;
    clear_has_operand();
  }
}
void Operand::set_allocated_ethernet_signal(::signal_source_definition::EthernetSource* ethernet_signal) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  clear_operand();
  if (ethernet_signal) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      ethernet_signal = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ethernet_signal, submessage_arena);
    }
    set_has_ethernet_signal();
    operand_.ethernet_signal_ = ethernet_signal;
  }
  // @@protoc_insertion_point(field_set_allocated:logical_expression.Operand.ethernet_signal)
}
void Operand::clear_ethernet_signal() {
  if (_internal_has_ethernet_signal()) {
    delete operand_.ethernet_signal_;
    clear_has_operand();
  }
}
void Operand::set_allocated_network_signal(::signal_source_definition::NetworkSource* network_signal) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  clear_operand();
  if (network_signal) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      network_signal = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, network_signal, submessage_arena);
    }
    set_has_network_signal();
    operand_.network_signal_ = network_signal;
  }
  // @@protoc_insertion_point(field_set_allocated:logical_expression.Operand.network_signal)
}
void Operand::clear_network_signal() {
  if (_internal_has_network_signal()) {
    delete operand_.network_signal_;
    clear_has_operand();
  }
}
void Operand::set_allocated_internal_signal(::signal_source_definition::InternalSource* internal_signal) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  clear_operand();
  if (internal_signal) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      internal_signal = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, internal_signal, submessage_arena);
    }
    set_has_internal_signal();
    operand_.internal_signal_ = internal_signal;
  }
  // @@protoc_insertion_point(field_set_allocated:logical_expression.Operand.internal_signal)
}
void Operand::clear_internal_signal() {
  if (_internal_has_internal_signal()) {
    delete operand_.internal_signal_;
    clear_has_operand();
  }
}
void Operand::set_allocated_processing_toolbox_signal(::signal_source_definition::ProcessingToolboxSource* processing_toolbox_signal) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  clear_operand();
  if (processing_toolbox_signal) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      processing_toolbox_signal = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, processing_toolbox_signal, submessage_arena);
    }
    set_has_processing_toolbox_signal();
    operand_.processing_toolbox_signal_ = processing_toolbox_signal;
  }
  // @@protoc_insertion_point(field_set_allocated:logical_expression.Operand.processing_toolbox_signal)
}
void Operand::clear_processing_toolbox_signal() {
  if (_internal_has_processing_toolbox_signal()) {
    delete operand_.processing_toolbox_signal_;
    clear_has_operand();
  }
}
void Operand::set_allocated_thriftme_signal(::signal_source_definition::ThriftmeSource* thriftme_signal) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  clear_operand();
  if (thriftme_signal) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      thriftme_signal = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, thriftme_signal, submessage_arena);
    }
    set_has_thriftme_signal();
    operand_.thriftme_signal_ = thriftme_signal;
  }
  // @@protoc_insertion_point(field_set_allocated:logical_expression.Operand.thriftme_signal)
}
void Operand::clear_thriftme_signal() {
  if (_internal_has_thriftme_signal()) {
    delete operand_.thriftme_signal_;
    clear_has_operand();
  }
}
Operand::Operand()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:logical_expression.Operand)
}
Operand::Operand(const Operand& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  clear_has_operand();
  switch (from.operand_case()) {
    case kInt64Value: {
      _internal_set_int64_value(from._internal_int64_value());
      break;
    }
    case kBoolValue: {
      _internal_set_bool_value(from._internal_bool_value());
      break;
    }
    case kStringValue: {
      _internal_set_string_value(from._internal_string_value());
      break;
    }
    case kBytesValue: {
      _internal_set_bytes_value(from._internal_bytes_value());
      break;
    }
    case kDefaultSignal: {
      _internal_mutable_default_signal()->::signal_source_definition::DefaultSource::MergeFrom(from._internal_default_signal());
      break;
    }
    case kCanSignal: {
      _internal_mutable_can_signal()->::signal_source_definition::CanSource::MergeFrom(from._internal_can_signal());
      break;
    }
    case kLinSignal: {
      _internal_mutable_lin_signal()->::signal_source_definition::LinSource::MergeFrom(from._internal_lin_signal());
      break;
    }
    case kEthernetSignal: {
      _internal_mutable_ethernet_signal()->::signal_source_definition::EthernetSource::MergeFrom(from._internal_ethernet_signal());
      break;
    }
    case kNetworkSignal: {
      _internal_mutable_network_signal()->::signal_source_definition::NetworkSource::MergeFrom(from._internal_network_signal());
      break;
    }
    case kInternalSignal: {
      _internal_mutable_internal_signal()->::signal_source_definition::InternalSource::MergeFrom(from._internal_internal_signal());
      break;
    }
    case kProcessingToolboxSignal: {
      _internal_mutable_processing_toolbox_signal()->::signal_source_definition::ProcessingToolboxSource::MergeFrom(from._internal_processing_toolbox_signal());
      break;
    }
    case kThriftmeSignal: {
      _internal_mutable_thriftme_signal()->::signal_source_definition::ThriftmeSource::MergeFrom(from._internal_thriftme_signal());
      break;
    }
    case OPERAND_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:logical_expression.Operand)
}

void Operand::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_Operand_logical_5fexpression_2eproto.base);
  clear_has_operand();
}

Operand::~Operand() {
  // @@protoc_insertion_point(destructor:logical_expression.Operand)
  SharedDtor();
}

void Operand::SharedDtor() {
  if (has_operand()) {
    clear_operand();
  }
}

void Operand::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Operand& Operand::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Operand_logical_5fexpression_2eproto.base);
  return *internal_default_instance();
}


void Operand::clear_operand() {
// @@protoc_insertion_point(one_of_clear_start:logical_expression.Operand)
  switch (operand_case()) {
    case kInt64Value: {
      // No need to clear
      break;
    }
    case kBoolValue: {
      // No need to clear
      break;
    }
    case kStringValue: {
      operand_.string_value_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
      break;
    }
    case kBytesValue: {
      operand_.bytes_value_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
      break;
    }
    case kDefaultSignal: {
      delete operand_.default_signal_;
      break;
    }
    case kCanSignal: {
      delete operand_.can_signal_;
      break;
    }
    case kLinSignal: {
      delete operand_.lin_signal_;
      break;
    }
    case kEthernetSignal: {
      delete operand_.ethernet_signal_;
      break;
    }
    case kNetworkSignal: {
      delete operand_.network_signal_;
      break;
    }
    case kInternalSignal: {
      delete operand_.internal_signal_;
      break;
    }
    case kProcessingToolboxSignal: {
      delete operand_.processing_toolbox_signal_;
      break;
    }
    case kThriftmeSignal: {
      delete operand_.thriftme_signal_;
      break;
    }
    case OPERAND_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = OPERAND_NOT_SET;
}


void Operand::Clear() {
// @@protoc_insertion_point(message_clear_start:logical_expression.Operand)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_operand();
  _internal_metadata_.Clear();
}

const char* Operand::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // int64 int64_value = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _internal_set_int64_value(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // bool bool_value = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _internal_set_bool_value(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // string string_value = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          auto str = _internal_mutable_string_value();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "logical_expression.Operand.string_value"));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // bytes bytes_value = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          auto str = _internal_mutable_bytes_value();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .signal_source_definition.DefaultSource default_signal = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_default_signal(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .signal_source_definition.CanSource can_signal = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_can_signal(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .signal_source_definition.LinSource lin_signal = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_lin_signal(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .signal_source_definition.EthernetSource ethernet_signal = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_ethernet_signal(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .signal_source_definition.NetworkSource network_signal = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_network_signal(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .signal_source_definition.InternalSource internal_signal = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_internal_signal(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .signal_source_definition.ProcessingToolboxSource processing_toolbox_signal = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_processing_toolbox_signal(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .signal_source_definition.ThriftmeSource thriftme_signal = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_thriftme_signal(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Operand::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:logical_expression.Operand)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // int64 int64_value = 1;
  if (_internal_has_int64_value()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(1, this->_internal_int64_value(), target);
  }

  // bool bool_value = 2;
  if (_internal_has_bool_value()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(2, this->_internal_bool_value(), target);
  }

  // string string_value = 3;
  if (_internal_has_string_value()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_string_value().data(), static_cast<int>(this->_internal_string_value().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "logical_expression.Operand.string_value");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_string_value(), target);
  }

  // bytes bytes_value = 4;
  if (_internal_has_bytes_value()) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_bytes_value(), target);
  }

  // .signal_source_definition.DefaultSource default_signal = 5;
  if (_internal_has_default_signal()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        5, _Internal::default_signal(this), target, stream);
  }

  // .signal_source_definition.CanSource can_signal = 6;
  if (_internal_has_can_signal()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        6, _Internal::can_signal(this), target, stream);
  }

  // .signal_source_definition.LinSource lin_signal = 7;
  if (_internal_has_lin_signal()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        7, _Internal::lin_signal(this), target, stream);
  }

  // .signal_source_definition.EthernetSource ethernet_signal = 8;
  if (_internal_has_ethernet_signal()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        8, _Internal::ethernet_signal(this), target, stream);
  }

  // .signal_source_definition.NetworkSource network_signal = 9;
  if (_internal_has_network_signal()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        9, _Internal::network_signal(this), target, stream);
  }

  // .signal_source_definition.InternalSource internal_signal = 10;
  if (_internal_has_internal_signal()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        10, _Internal::internal_signal(this), target, stream);
  }

  // .signal_source_definition.ProcessingToolboxSource processing_toolbox_signal = 11;
  if (_internal_has_processing_toolbox_signal()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        11, _Internal::processing_toolbox_signal(this), target, stream);
  }

  // .signal_source_definition.ThriftmeSource thriftme_signal = 12;
  if (_internal_has_thriftme_signal()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        12, _Internal::thriftme_signal(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:logical_expression.Operand)
  return target;
}

size_t Operand::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:logical_expression.Operand)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (operand_case()) {
    // int64 int64_value = 1;
    case kInt64Value: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->_internal_int64_value());
      break;
    }
    // bool bool_value = 2;
    case kBoolValue: {
      total_size += 1 + 1;
      break;
    }
    // string string_value = 3;
    case kStringValue: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_string_value());
      break;
    }
    // bytes bytes_value = 4;
    case kBytesValue: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_bytes_value());
      break;
    }
    // .signal_source_definition.DefaultSource default_signal = 5;
    case kDefaultSignal: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *operand_.default_signal_);
      break;
    }
    // .signal_source_definition.CanSource can_signal = 6;
    case kCanSignal: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *operand_.can_signal_);
      break;
    }
    // .signal_source_definition.LinSource lin_signal = 7;
    case kLinSignal: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *operand_.lin_signal_);
      break;
    }
    // .signal_source_definition.EthernetSource ethernet_signal = 8;
    case kEthernetSignal: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *operand_.ethernet_signal_);
      break;
    }
    // .signal_source_definition.NetworkSource network_signal = 9;
    case kNetworkSignal: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *operand_.network_signal_);
      break;
    }
    // .signal_source_definition.InternalSource internal_signal = 10;
    case kInternalSignal: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *operand_.internal_signal_);
      break;
    }
    // .signal_source_definition.ProcessingToolboxSource processing_toolbox_signal = 11;
    case kProcessingToolboxSignal: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *operand_.processing_toolbox_signal_);
      break;
    }
    // .signal_source_definition.ThriftmeSource thriftme_signal = 12;
    case kThriftmeSignal: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *operand_.thriftme_signal_);
      break;
    }
    case OPERAND_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Operand::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:logical_expression.Operand)
  GOOGLE_DCHECK_NE(&from, this);
  const Operand* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<Operand>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:logical_expression.Operand)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:logical_expression.Operand)
    MergeFrom(*source);
  }
}

void Operand::MergeFrom(const Operand& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:logical_expression.Operand)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.operand_case()) {
    case kInt64Value: {
      _internal_set_int64_value(from._internal_int64_value());
      break;
    }
    case kBoolValue: {
      _internal_set_bool_value(from._internal_bool_value());
      break;
    }
    case kStringValue: {
      _internal_set_string_value(from._internal_string_value());
      break;
    }
    case kBytesValue: {
      _internal_set_bytes_value(from._internal_bytes_value());
      break;
    }
    case kDefaultSignal: {
      _internal_mutable_default_signal()->::signal_source_definition::DefaultSource::MergeFrom(from._internal_default_signal());
      break;
    }
    case kCanSignal: {
      _internal_mutable_can_signal()->::signal_source_definition::CanSource::MergeFrom(from._internal_can_signal());
      break;
    }
    case kLinSignal: {
      _internal_mutable_lin_signal()->::signal_source_definition::LinSource::MergeFrom(from._internal_lin_signal());
      break;
    }
    case kEthernetSignal: {
      _internal_mutable_ethernet_signal()->::signal_source_definition::EthernetSource::MergeFrom(from._internal_ethernet_signal());
      break;
    }
    case kNetworkSignal: {
      _internal_mutable_network_signal()->::signal_source_definition::NetworkSource::MergeFrom(from._internal_network_signal());
      break;
    }
    case kInternalSignal: {
      _internal_mutable_internal_signal()->::signal_source_definition::InternalSource::MergeFrom(from._internal_internal_signal());
      break;
    }
    case kProcessingToolboxSignal: {
      _internal_mutable_processing_toolbox_signal()->::signal_source_definition::ProcessingToolboxSource::MergeFrom(from._internal_processing_toolbox_signal());
      break;
    }
    case kThriftmeSignal: {
      _internal_mutable_thriftme_signal()->::signal_source_definition::ThriftmeSource::MergeFrom(from._internal_thriftme_signal());
      break;
    }
    case OPERAND_NOT_SET: {
      break;
    }
  }
}

void Operand::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:logical_expression.Operand)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Operand::CopyFrom(const Operand& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:logical_expression.Operand)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Operand::IsInitialized() const {
  return true;
}

void Operand::InternalSwap(Operand* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(operand_, other->operand_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata Operand::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void ComparisonExpression::InitAsDefaultInstance() {
  ::logical_expression::_ComparisonExpression_default_instance_._instance.get_mutable()->first_operation_ = const_cast< ::logical_expression::Operation*>(
      ::logical_expression::Operation::internal_default_instance());
  ::logical_expression::_ComparisonExpression_default_instance_._instance.get_mutable()->second_operation_ = const_cast< ::logical_expression::Operation*>(
      ::logical_expression::Operation::internal_default_instance());
}
class ComparisonExpression::_Internal {
 public:
  static const ::logical_expression::Operation& first_operation(const ComparisonExpression* msg);
  static const ::logical_expression::Operation& second_operation(const ComparisonExpression* msg);
};

const ::logical_expression::Operation&
ComparisonExpression::_Internal::first_operation(const ComparisonExpression* msg) {
  return *msg->first_operation_;
}
const ::logical_expression::Operation&
ComparisonExpression::_Internal::second_operation(const ComparisonExpression* msg) {
  return *msg->second_operation_;
}
ComparisonExpression::ComparisonExpression()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:logical_expression.ComparisonExpression)
}
ComparisonExpression::ComparisonExpression(const ComparisonExpression& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from._internal_has_first_operation()) {
    first_operation_ = new ::logical_expression::Operation(*from.first_operation_);
  } else {
    first_operation_ = nullptr;
  }
  if (from._internal_has_second_operation()) {
    second_operation_ = new ::logical_expression::Operation(*from.second_operation_);
  } else {
    second_operation_ = nullptr;
  }
  ::memcpy(&not__, &from.not__,
    static_cast<size_t>(reinterpret_cast<char*>(&operator__) -
    reinterpret_cast<char*>(&not__)) + sizeof(operator__));
  // @@protoc_insertion_point(copy_constructor:logical_expression.ComparisonExpression)
}

void ComparisonExpression::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_ComparisonExpression_logical_5fexpression_2eproto.base);
  ::memset(&first_operation_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&operator__) -
      reinterpret_cast<char*>(&first_operation_)) + sizeof(operator__));
}

ComparisonExpression::~ComparisonExpression() {
  // @@protoc_insertion_point(destructor:logical_expression.ComparisonExpression)
  SharedDtor();
}

void ComparisonExpression::SharedDtor() {
  if (this != internal_default_instance()) delete first_operation_;
  if (this != internal_default_instance()) delete second_operation_;
}

void ComparisonExpression::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ComparisonExpression& ComparisonExpression::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_ComparisonExpression_logical_5fexpression_2eproto.base);
  return *internal_default_instance();
}


void ComparisonExpression::Clear() {
// @@protoc_insertion_point(message_clear_start:logical_expression.ComparisonExpression)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaNoVirtual() == nullptr && first_operation_ != nullptr) {
    delete first_operation_;
  }
  first_operation_ = nullptr;
  if (GetArenaNoVirtual() == nullptr && second_operation_ != nullptr) {
    delete second_operation_;
  }
  second_operation_ = nullptr;
  ::memset(&not__, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&operator__) -
      reinterpret_cast<char*>(&not__)) + sizeof(operator__));
  _internal_metadata_.Clear();
}

const char* ComparisonExpression::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // bool not = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          not__ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .logical_expression.Operation first_operation = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_first_operation(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .logical_expression.ComparisonOperatorType operator = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          _internal_set_operator_(static_cast<::logical_expression::ComparisonOperatorType>(val));
        } else goto handle_unusual;
        continue;
      // .logical_expression.Operation second_operation = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_second_operation(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* ComparisonExpression::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:logical_expression.ComparisonExpression)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // bool not = 1;
  if (this->not_() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(1, this->_internal_not_(), target);
  }

  // .logical_expression.Operation first_operation = 2;
  if (this->has_first_operation()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::first_operation(this), target, stream);
  }

  // .logical_expression.ComparisonOperatorType operator = 3;
  if (this->operator_() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      3, this->_internal_operator_(), target);
  }

  // .logical_expression.Operation second_operation = 4;
  if (this->has_second_operation()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::second_operation(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:logical_expression.ComparisonExpression)
  return target;
}

size_t ComparisonExpression::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:logical_expression.ComparisonExpression)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .logical_expression.Operation first_operation = 2;
  if (this->has_first_operation()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *first_operation_);
  }

  // .logical_expression.Operation second_operation = 4;
  if (this->has_second_operation()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *second_operation_);
  }

  // bool not = 1;
  if (this->not_() != 0) {
    total_size += 1 + 1;
  }

  // .logical_expression.ComparisonOperatorType operator = 3;
  if (this->operator_() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_operator_());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ComparisonExpression::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:logical_expression.ComparisonExpression)
  GOOGLE_DCHECK_NE(&from, this);
  const ComparisonExpression* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<ComparisonExpression>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:logical_expression.ComparisonExpression)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:logical_expression.ComparisonExpression)
    MergeFrom(*source);
  }
}

void ComparisonExpression::MergeFrom(const ComparisonExpression& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:logical_expression.ComparisonExpression)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_first_operation()) {
    _internal_mutable_first_operation()->::logical_expression::Operation::MergeFrom(from._internal_first_operation());
  }
  if (from.has_second_operation()) {
    _internal_mutable_second_operation()->::logical_expression::Operation::MergeFrom(from._internal_second_operation());
  }
  if (from.not_() != 0) {
    _internal_set_not_(from._internal_not_());
  }
  if (from.operator_() != 0) {
    _internal_set_operator_(from._internal_operator_());
  }
}

void ComparisonExpression::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:logical_expression.ComparisonExpression)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ComparisonExpression::CopyFrom(const ComparisonExpression& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:logical_expression.ComparisonExpression)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ComparisonExpression::IsInitialized() const {
  return true;
}

void ComparisonExpression::InternalSwap(ComparisonExpression* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(first_operation_, other->first_operation_);
  swap(second_operation_, other->second_operation_);
  swap(not__, other->not__);
  swap(operator__, other->operator__);
}

::PROTOBUF_NAMESPACE_ID::Metadata ComparisonExpression::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void Operation::InitAsDefaultInstance() {
  ::logical_expression::_Operation_default_instance_._instance.get_mutable()->first_operand_ = const_cast< ::logical_expression::Operand*>(
      ::logical_expression::Operand::internal_default_instance());
  ::logical_expression::_Operation_default_instance_._instance.get_mutable()->second_operand_ = const_cast< ::logical_expression::Operand*>(
      ::logical_expression::Operand::internal_default_instance());
}
class Operation::_Internal {
 public:
  static const ::logical_expression::Operand& first_operand(const Operation* msg);
  static const ::logical_expression::Operand& second_operand(const Operation* msg);
};

const ::logical_expression::Operand&
Operation::_Internal::first_operand(const Operation* msg) {
  return *msg->first_operand_;
}
const ::logical_expression::Operand&
Operation::_Internal::second_operand(const Operation* msg) {
  return *msg->second_operand_;
}
Operation::Operation()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:logical_expression.Operation)
}
Operation::Operation(const Operation& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from._internal_has_first_operand()) {
    first_operand_ = new ::logical_expression::Operand(*from.first_operand_);
  } else {
    first_operand_ = nullptr;
  }
  if (from._internal_has_second_operand()) {
    second_operand_ = new ::logical_expression::Operand(*from.second_operand_);
  } else {
    second_operand_ = nullptr;
  }
  operator__ = from.operator__;
  // @@protoc_insertion_point(copy_constructor:logical_expression.Operation)
}

void Operation::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_Operation_logical_5fexpression_2eproto.base);
  ::memset(&first_operand_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&operator__) -
      reinterpret_cast<char*>(&first_operand_)) + sizeof(operator__));
}

Operation::~Operation() {
  // @@protoc_insertion_point(destructor:logical_expression.Operation)
  SharedDtor();
}

void Operation::SharedDtor() {
  if (this != internal_default_instance()) delete first_operand_;
  if (this != internal_default_instance()) delete second_operand_;
}

void Operation::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Operation& Operation::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Operation_logical_5fexpression_2eproto.base);
  return *internal_default_instance();
}


void Operation::Clear() {
// @@protoc_insertion_point(message_clear_start:logical_expression.Operation)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaNoVirtual() == nullptr && first_operand_ != nullptr) {
    delete first_operand_;
  }
  first_operand_ = nullptr;
  if (GetArenaNoVirtual() == nullptr && second_operand_ != nullptr) {
    delete second_operand_;
  }
  second_operand_ = nullptr;
  operator__ = 0;
  _internal_metadata_.Clear();
}

const char* Operation::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // .logical_expression.Operand first_operand = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_first_operand(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .logical_expression.OperationType operator = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          _internal_set_operator_(static_cast<::logical_expression::OperationType>(val));
        } else goto handle_unusual;
        continue;
      // .logical_expression.Operand second_operand = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_second_operand(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Operation::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:logical_expression.Operation)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .logical_expression.Operand first_operand = 1;
  if (this->has_first_operand()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::first_operand(this), target, stream);
  }

  // .logical_expression.OperationType operator = 2;
  if (this->operator_() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_operator_(), target);
  }

  // .logical_expression.Operand second_operand = 3;
  if (this->has_second_operand()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::second_operand(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:logical_expression.Operation)
  return target;
}

size_t Operation::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:logical_expression.Operation)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .logical_expression.Operand first_operand = 1;
  if (this->has_first_operand()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *first_operand_);
  }

  // .logical_expression.Operand second_operand = 3;
  if (this->has_second_operand()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *second_operand_);
  }

  // .logical_expression.OperationType operator = 2;
  if (this->operator_() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_operator_());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Operation::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:logical_expression.Operation)
  GOOGLE_DCHECK_NE(&from, this);
  const Operation* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<Operation>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:logical_expression.Operation)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:logical_expression.Operation)
    MergeFrom(*source);
  }
}

void Operation::MergeFrom(const Operation& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:logical_expression.Operation)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_first_operand()) {
    _internal_mutable_first_operand()->::logical_expression::Operand::MergeFrom(from._internal_first_operand());
  }
  if (from.has_second_operand()) {
    _internal_mutable_second_operand()->::logical_expression::Operand::MergeFrom(from._internal_second_operand());
  }
  if (from.operator_() != 0) {
    _internal_set_operator_(from._internal_operator_());
  }
}

void Operation::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:logical_expression.Operation)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Operation::CopyFrom(const Operation& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:logical_expression.Operation)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Operation::IsInitialized() const {
  return true;
}

void Operation::InternalSwap(Operation* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(first_operand_, other->first_operand_);
  swap(second_operand_, other->second_operand_);
  swap(operator__, other->operator__);
}

::PROTOBUF_NAMESPACE_ID::Metadata Operation::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void TransitionExpression::InitAsDefaultInstance() {
  ::logical_expression::_TransitionExpression_default_instance_._instance.get_mutable()->signal_identifier_ = const_cast< ::logical_expression::Operand*>(
      ::logical_expression::Operand::internal_default_instance());
  ::logical_expression::_TransitionExpression_default_instance_._instance.get_mutable()->from_value_ = const_cast< ::logical_expression::Operand*>(
      ::logical_expression::Operand::internal_default_instance());
  ::logical_expression::_TransitionExpression_default_instance_._instance.get_mutable()->to_value_ = const_cast< ::logical_expression::Operand*>(
      ::logical_expression::Operand::internal_default_instance());
}
class TransitionExpression::_Internal {
 public:
  static const ::logical_expression::Operand& signal_identifier(const TransitionExpression* msg);
  static const ::logical_expression::Operand& from_value(const TransitionExpression* msg);
  static const ::logical_expression::Operand& to_value(const TransitionExpression* msg);
};

const ::logical_expression::Operand&
TransitionExpression::_Internal::signal_identifier(const TransitionExpression* msg) {
  return *msg->signal_identifier_;
}
const ::logical_expression::Operand&
TransitionExpression::_Internal::from_value(const TransitionExpression* msg) {
  return *msg->from_value_;
}
const ::logical_expression::Operand&
TransitionExpression::_Internal::to_value(const TransitionExpression* msg) {
  return *msg->to_value_;
}
TransitionExpression::TransitionExpression()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:logical_expression.TransitionExpression)
}
TransitionExpression::TransitionExpression(const TransitionExpression& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from._internal_has_signal_identifier()) {
    signal_identifier_ = new ::logical_expression::Operand(*from.signal_identifier_);
  } else {
    signal_identifier_ = nullptr;
  }
  if (from._internal_has_from_value()) {
    from_value_ = new ::logical_expression::Operand(*from.from_value_);
  } else {
    from_value_ = nullptr;
  }
  if (from._internal_has_to_value()) {
    to_value_ = new ::logical_expression::Operand(*from.to_value_);
  } else {
    to_value_ = nullptr;
  }
  ::memcpy(&from_operator_, &from.from_operator_,
    static_cast<size_t>(reinterpret_cast<char*>(&to_operator_) -
    reinterpret_cast<char*>(&from_operator_)) + sizeof(to_operator_));
  // @@protoc_insertion_point(copy_constructor:logical_expression.TransitionExpression)
}

void TransitionExpression::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_TransitionExpression_logical_5fexpression_2eproto.base);
  ::memset(&signal_identifier_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&to_operator_) -
      reinterpret_cast<char*>(&signal_identifier_)) + sizeof(to_operator_));
}

TransitionExpression::~TransitionExpression() {
  // @@protoc_insertion_point(destructor:logical_expression.TransitionExpression)
  SharedDtor();
}

void TransitionExpression::SharedDtor() {
  if (this != internal_default_instance()) delete signal_identifier_;
  if (this != internal_default_instance()) delete from_value_;
  if (this != internal_default_instance()) delete to_value_;
}

void TransitionExpression::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TransitionExpression& TransitionExpression::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_TransitionExpression_logical_5fexpression_2eproto.base);
  return *internal_default_instance();
}


void TransitionExpression::Clear() {
// @@protoc_insertion_point(message_clear_start:logical_expression.TransitionExpression)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaNoVirtual() == nullptr && signal_identifier_ != nullptr) {
    delete signal_identifier_;
  }
  signal_identifier_ = nullptr;
  if (GetArenaNoVirtual() == nullptr && from_value_ != nullptr) {
    delete from_value_;
  }
  from_value_ = nullptr;
  if (GetArenaNoVirtual() == nullptr && to_value_ != nullptr) {
    delete to_value_;
  }
  to_value_ = nullptr;
  ::memset(&from_operator_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&to_operator_) -
      reinterpret_cast<char*>(&from_operator_)) + sizeof(to_operator_));
  _internal_metadata_.Clear();
}

const char* TransitionExpression::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // .logical_expression.Operand signal_identifier = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_signal_identifier(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .logical_expression.ComparisonOperatorType from_operator = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          _internal_set_from_operator(static_cast<::logical_expression::ComparisonOperatorType>(val));
        } else goto handle_unusual;
        continue;
      // .logical_expression.Operand from_value = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_from_value(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .logical_expression.ComparisonOperatorType to_operator = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          _internal_set_to_operator(static_cast<::logical_expression::ComparisonOperatorType>(val));
        } else goto handle_unusual;
        continue;
      // .logical_expression.Operand to_value = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_to_value(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* TransitionExpression::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:logical_expression.TransitionExpression)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .logical_expression.Operand signal_identifier = 1;
  if (this->has_signal_identifier()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::signal_identifier(this), target, stream);
  }

  // .logical_expression.ComparisonOperatorType from_operator = 2;
  if (this->from_operator() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_from_operator(), target);
  }

  // .logical_expression.Operand from_value = 3;
  if (this->has_from_value()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::from_value(this), target, stream);
  }

  // .logical_expression.ComparisonOperatorType to_operator = 4;
  if (this->to_operator() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      4, this->_internal_to_operator(), target);
  }

  // .logical_expression.Operand to_value = 5;
  if (this->has_to_value()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        5, _Internal::to_value(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:logical_expression.TransitionExpression)
  return target;
}

size_t TransitionExpression::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:logical_expression.TransitionExpression)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .logical_expression.Operand signal_identifier = 1;
  if (this->has_signal_identifier()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *signal_identifier_);
  }

  // .logical_expression.Operand from_value = 3;
  if (this->has_from_value()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *from_value_);
  }

  // .logical_expression.Operand to_value = 5;
  if (this->has_to_value()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *to_value_);
  }

  // .logical_expression.ComparisonOperatorType from_operator = 2;
  if (this->from_operator() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_from_operator());
  }

  // .logical_expression.ComparisonOperatorType to_operator = 4;
  if (this->to_operator() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_to_operator());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TransitionExpression::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:logical_expression.TransitionExpression)
  GOOGLE_DCHECK_NE(&from, this);
  const TransitionExpression* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<TransitionExpression>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:logical_expression.TransitionExpression)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:logical_expression.TransitionExpression)
    MergeFrom(*source);
  }
}

void TransitionExpression::MergeFrom(const TransitionExpression& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:logical_expression.TransitionExpression)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_signal_identifier()) {
    _internal_mutable_signal_identifier()->::logical_expression::Operand::MergeFrom(from._internal_signal_identifier());
  }
  if (from.has_from_value()) {
    _internal_mutable_from_value()->::logical_expression::Operand::MergeFrom(from._internal_from_value());
  }
  if (from.has_to_value()) {
    _internal_mutable_to_value()->::logical_expression::Operand::MergeFrom(from._internal_to_value());
  }
  if (from.from_operator() != 0) {
    _internal_set_from_operator(from._internal_from_operator());
  }
  if (from.to_operator() != 0) {
    _internal_set_to_operator(from._internal_to_operator());
  }
}

void TransitionExpression::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:logical_expression.TransitionExpression)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TransitionExpression::CopyFrom(const TransitionExpression& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:logical_expression.TransitionExpression)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TransitionExpression::IsInitialized() const {
  return true;
}

void TransitionExpression::InternalSwap(TransitionExpression* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(signal_identifier_, other->signal_identifier_);
  swap(from_value_, other->from_value_);
  swap(to_value_, other->to_value_);
  swap(from_operator_, other->from_operator_);
  swap(to_operator_, other->to_operator_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TransitionExpression::GetMetadata() const {
  return GetMetadataStatic();
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace logical_expression
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::logical_expression::LogicalExpression* Arena::CreateMaybeMessage< ::logical_expression::LogicalExpression >(Arena* arena) {
  return Arena::CreateInternal< ::logical_expression::LogicalExpression >(arena);
}
template<> PROTOBUF_NOINLINE ::logical_expression::LogicalOperand* Arena::CreateMaybeMessage< ::logical_expression::LogicalOperand >(Arena* arena) {
  return Arena::CreateInternal< ::logical_expression::LogicalOperand >(arena);
}
template<> PROTOBUF_NOINLINE ::logical_expression::Operand* Arena::CreateMaybeMessage< ::logical_expression::Operand >(Arena* arena) {
  return Arena::CreateInternal< ::logical_expression::Operand >(arena);
}
template<> PROTOBUF_NOINLINE ::logical_expression::ComparisonExpression* Arena::CreateMaybeMessage< ::logical_expression::ComparisonExpression >(Arena* arena) {
  return Arena::CreateInternal< ::logical_expression::ComparisonExpression >(arena);
}
template<> PROTOBUF_NOINLINE ::logical_expression::Operation* Arena::CreateMaybeMessage< ::logical_expression::Operation >(Arena* arena) {
  return Arena::CreateInternal< ::logical_expression::Operation >(arena);
}
template<> PROTOBUF_NOINLINE ::logical_expression::TransitionExpression* Arena::CreateMaybeMessage< ::logical_expression::TransitionExpression >(Arena* arena) {
  return Arena::CreateInternal< ::logical_expression::TransitionExpression >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
