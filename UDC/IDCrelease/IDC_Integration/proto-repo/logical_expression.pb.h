// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: logical_expression.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_logical_5fexpression_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_logical_5fexpression_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3011000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3011000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "signal_source_definition.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_logical_5fexpression_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_logical_5fexpression_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[6]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_logical_5fexpression_2eproto;
namespace logical_expression {
class ComparisonExpression;
class ComparisonExpressionDefaultTypeInternal;
extern ComparisonExpressionDefaultTypeInternal _ComparisonExpression_default_instance_;
class LogicalExpression;
class LogicalExpressionDefaultTypeInternal;
extern LogicalExpressionDefaultTypeInternal _LogicalExpression_default_instance_;
class LogicalOperand;
class LogicalOperandDefaultTypeInternal;
extern LogicalOperandDefaultTypeInternal _LogicalOperand_default_instance_;
class Operand;
class OperandDefaultTypeInternal;
extern OperandDefaultTypeInternal _Operand_default_instance_;
class Operation;
class OperationDefaultTypeInternal;
extern OperationDefaultTypeInternal _Operation_default_instance_;
class TransitionExpression;
class TransitionExpressionDefaultTypeInternal;
extern TransitionExpressionDefaultTypeInternal _TransitionExpression_default_instance_;
}  // namespace logical_expression
PROTOBUF_NAMESPACE_OPEN
template<> ::logical_expression::ComparisonExpression* Arena::CreateMaybeMessage<::logical_expression::ComparisonExpression>(Arena*);
template<> ::logical_expression::LogicalExpression* Arena::CreateMaybeMessage<::logical_expression::LogicalExpression>(Arena*);
template<> ::logical_expression::LogicalOperand* Arena::CreateMaybeMessage<::logical_expression::LogicalOperand>(Arena*);
template<> ::logical_expression::Operand* Arena::CreateMaybeMessage<::logical_expression::Operand>(Arena*);
template<> ::logical_expression::Operation* Arena::CreateMaybeMessage<::logical_expression::Operation>(Arena*);
template<> ::logical_expression::TransitionExpression* Arena::CreateMaybeMessage<::logical_expression::TransitionExpression>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace logical_expression {

enum LogicalOperator : int {
  UNKNOWN_LOGICAL_OPERATOR = 0,
  AND = 1,
  OR = 2,
  LogicalOperator_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  LogicalOperator_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool LogicalOperator_IsValid(int value);
constexpr LogicalOperator LogicalOperator_MIN = UNKNOWN_LOGICAL_OPERATOR;
constexpr LogicalOperator LogicalOperator_MAX = OR;
constexpr int LogicalOperator_ARRAYSIZE = LogicalOperator_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LogicalOperator_descriptor();
template<typename T>
inline const std::string& LogicalOperator_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LogicalOperator>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LogicalOperator_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    LogicalOperator_descriptor(), enum_t_value);
}
inline bool LogicalOperator_Parse(
    const std::string& name, LogicalOperator* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<LogicalOperator>(
    LogicalOperator_descriptor(), name, value);
}
enum OperationType : int {
  UNKNOWN_OPERATION_TYPE = 0,
  NO_OPERATION = 1,
  SUM = 2,
  SUBTRACTION = 3,
  MULTIPLICATION = 4,
  DIVISION = 5,
  OperationType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  OperationType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool OperationType_IsValid(int value);
constexpr OperationType OperationType_MIN = UNKNOWN_OPERATION_TYPE;
constexpr OperationType OperationType_MAX = DIVISION;
constexpr int OperationType_ARRAYSIZE = OperationType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* OperationType_descriptor();
template<typename T>
inline const std::string& OperationType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, OperationType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function OperationType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    OperationType_descriptor(), enum_t_value);
}
inline bool OperationType_Parse(
    const std::string& name, OperationType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<OperationType>(
    OperationType_descriptor(), name, value);
}
enum ComparisonOperatorType : int {
  UNKNOWN_COMPARISON_OPERATOR_TYPE = 0,
  EQUAL = 1,
  NOT_EQUAL = 2,
  GREATER = 3,
  LESS = 4,
  GREATER_OR_EQUAL = 5,
  LESS_OR_EQUAL = 6,
  ComparisonOperatorType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ComparisonOperatorType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ComparisonOperatorType_IsValid(int value);
constexpr ComparisonOperatorType ComparisonOperatorType_MIN = UNKNOWN_COMPARISON_OPERATOR_TYPE;
constexpr ComparisonOperatorType ComparisonOperatorType_MAX = LESS_OR_EQUAL;
constexpr int ComparisonOperatorType_ARRAYSIZE = ComparisonOperatorType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ComparisonOperatorType_descriptor();
template<typename T>
inline const std::string& ComparisonOperatorType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ComparisonOperatorType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ComparisonOperatorType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ComparisonOperatorType_descriptor(), enum_t_value);
}
inline bool ComparisonOperatorType_Parse(
    const std::string& name, ComparisonOperatorType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ComparisonOperatorType>(
    ComparisonOperatorType_descriptor(), name, value);
}
// ===================================================================

class LogicalExpression :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:logical_expression.LogicalExpression) */ {
 public:
  LogicalExpression();
  virtual ~LogicalExpression();

  LogicalExpression(const LogicalExpression& from);
  LogicalExpression(LogicalExpression&& from) noexcept
    : LogicalExpression() {
    *this = ::std::move(from);
  }

  inline LogicalExpression& operator=(const LogicalExpression& from) {
    CopyFrom(from);
    return *this;
  }
  inline LogicalExpression& operator=(LogicalExpression&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LogicalExpression& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LogicalExpression* internal_default_instance() {
    return reinterpret_cast<const LogicalExpression*>(
               &_LogicalExpression_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(LogicalExpression& a, LogicalExpression& b) {
    a.Swap(&b);
  }
  inline void Swap(LogicalExpression* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LogicalExpression* New() const final {
    return CreateMaybeMessage<LogicalExpression>(nullptr);
  }

  LogicalExpression* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LogicalExpression>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LogicalExpression& from);
  void MergeFrom(const LogicalExpression& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LogicalExpression* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "logical_expression.LogicalExpression";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_logical_5fexpression_2eproto);
    return ::descriptor_table_logical_5fexpression_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOperandFieldNumber = 3,
    kNotFieldNumber = 1,
    kOperatorFieldNumber = 2,
  };
  // repeated .logical_expression.LogicalOperand operand = 3;
  int operand_size() const;
  private:
  int _internal_operand_size() const;
  public:
  void clear_operand();
  ::logical_expression::LogicalOperand* mutable_operand(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::logical_expression::LogicalOperand >*
      mutable_operand();
  private:
  const ::logical_expression::LogicalOperand& _internal_operand(int index) const;
  ::logical_expression::LogicalOperand* _internal_add_operand();
  public:
  const ::logical_expression::LogicalOperand& operand(int index) const;
  ::logical_expression::LogicalOperand* add_operand();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::logical_expression::LogicalOperand >&
      operand() const;

  // bool not = 1;
  void clear_not_();
  bool not_() const;
  void set_not_(bool value);
  private:
  bool _internal_not_() const;
  void _internal_set_not_(bool value);
  public:

  // .logical_expression.LogicalOperator operator = 2;
  void clear_operator_();
  ::logical_expression::LogicalOperator operator_() const;
  void set_operator_(::logical_expression::LogicalOperator value);
  private:
  ::logical_expression::LogicalOperator _internal_operator_() const;
  void _internal_set_operator_(::logical_expression::LogicalOperator value);
  public:

  // @@protoc_insertion_point(class_scope:logical_expression.LogicalExpression)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::logical_expression::LogicalOperand > operand_;
  bool not__;
  int operator__;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_logical_5fexpression_2eproto;
};
// -------------------------------------------------------------------

class LogicalOperand :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:logical_expression.LogicalOperand) */ {
 public:
  LogicalOperand();
  virtual ~LogicalOperand();

  LogicalOperand(const LogicalOperand& from);
  LogicalOperand(LogicalOperand&& from) noexcept
    : LogicalOperand() {
    *this = ::std::move(from);
  }

  inline LogicalOperand& operator=(const LogicalOperand& from) {
    CopyFrom(from);
    return *this;
  }
  inline LogicalOperand& operator=(LogicalOperand&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LogicalOperand& default_instance();

  enum ExpressionFunctionCase {
    kComparisonExpression = 2,
    kTransitionExpression = 3,
    EXPRESSION_FUNCTION_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LogicalOperand* internal_default_instance() {
    return reinterpret_cast<const LogicalOperand*>(
               &_LogicalOperand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(LogicalOperand& a, LogicalOperand& b) {
    a.Swap(&b);
  }
  inline void Swap(LogicalOperand* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LogicalOperand* New() const final {
    return CreateMaybeMessage<LogicalOperand>(nullptr);
  }

  LogicalOperand* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LogicalOperand>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LogicalOperand& from);
  void MergeFrom(const LogicalOperand& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LogicalOperand* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "logical_expression.LogicalOperand";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_logical_5fexpression_2eproto);
    return ::descriptor_table_logical_5fexpression_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNotFieldNumber = 1,
    kComparisonExpressionFieldNumber = 2,
    kTransitionExpressionFieldNumber = 3,
  };
  // bool not = 1;
  void clear_not_();
  bool not_() const;
  void set_not_(bool value);
  private:
  bool _internal_not_() const;
  void _internal_set_not_(bool value);
  public:

  // .logical_expression.ComparisonExpression comparison_expression = 2;
  bool has_comparison_expression() const;
  private:
  bool _internal_has_comparison_expression() const;
  public:
  void clear_comparison_expression();
  const ::logical_expression::ComparisonExpression& comparison_expression() const;
  ::logical_expression::ComparisonExpression* release_comparison_expression();
  ::logical_expression::ComparisonExpression* mutable_comparison_expression();
  void set_allocated_comparison_expression(::logical_expression::ComparisonExpression* comparison_expression);
  private:
  const ::logical_expression::ComparisonExpression& _internal_comparison_expression() const;
  ::logical_expression::ComparisonExpression* _internal_mutable_comparison_expression();
  public:

  // .logical_expression.TransitionExpression transition_expression = 3;
  bool has_transition_expression() const;
  private:
  bool _internal_has_transition_expression() const;
  public:
  void clear_transition_expression();
  const ::logical_expression::TransitionExpression& transition_expression() const;
  ::logical_expression::TransitionExpression* release_transition_expression();
  ::logical_expression::TransitionExpression* mutable_transition_expression();
  void set_allocated_transition_expression(::logical_expression::TransitionExpression* transition_expression);
  private:
  const ::logical_expression::TransitionExpression& _internal_transition_expression() const;
  ::logical_expression::TransitionExpression* _internal_mutable_transition_expression();
  public:

  void clear_expression_function();
  ExpressionFunctionCase expression_function_case() const;
  // @@protoc_insertion_point(class_scope:logical_expression.LogicalOperand)
 private:
  class _Internal;
  void set_has_comparison_expression();
  void set_has_transition_expression();

  inline bool has_expression_function() const;
  inline void clear_has_expression_function();

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  bool not__;
  union ExpressionFunctionUnion {
    ExpressionFunctionUnion() {}
    ::logical_expression::ComparisonExpression* comparison_expression_;
    ::logical_expression::TransitionExpression* transition_expression_;
  } expression_function_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_logical_5fexpression_2eproto;
};
// -------------------------------------------------------------------

class Operand :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:logical_expression.Operand) */ {
 public:
  Operand();
  virtual ~Operand();

  Operand(const Operand& from);
  Operand(Operand&& from) noexcept
    : Operand() {
    *this = ::std::move(from);
  }

  inline Operand& operator=(const Operand& from) {
    CopyFrom(from);
    return *this;
  }
  inline Operand& operator=(Operand&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Operand& default_instance();

  enum OperandCase {
    kInt64Value = 1,
    kBoolValue = 2,
    kStringValue = 3,
    kBytesValue = 4,
    kDefaultSignal = 5,
    kCanSignal = 6,
    kLinSignal = 7,
    kEthernetSignal = 8,
    kNetworkSignal = 9,
    kInternalSignal = 10,
    kProcessingToolboxSignal = 11,
    kThriftmeSignal = 12,
    OPERAND_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Operand* internal_default_instance() {
    return reinterpret_cast<const Operand*>(
               &_Operand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Operand& a, Operand& b) {
    a.Swap(&b);
  }
  inline void Swap(Operand* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Operand* New() const final {
    return CreateMaybeMessage<Operand>(nullptr);
  }

  Operand* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Operand>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Operand& from);
  void MergeFrom(const Operand& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Operand* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "logical_expression.Operand";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_logical_5fexpression_2eproto);
    return ::descriptor_table_logical_5fexpression_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInt64ValueFieldNumber = 1,
    kBoolValueFieldNumber = 2,
    kStringValueFieldNumber = 3,
    kBytesValueFieldNumber = 4,
    kDefaultSignalFieldNumber = 5,
    kCanSignalFieldNumber = 6,
    kLinSignalFieldNumber = 7,
    kEthernetSignalFieldNumber = 8,
    kNetworkSignalFieldNumber = 9,
    kInternalSignalFieldNumber = 10,
    kProcessingToolboxSignalFieldNumber = 11,
    kThriftmeSignalFieldNumber = 12,
  };
  // int64 int64_value = 1;
  private:
  bool _internal_has_int64_value() const;
  public:
  void clear_int64_value();
  ::PROTOBUF_NAMESPACE_ID::int64 int64_value() const;
  void set_int64_value(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_int64_value() const;
  void _internal_set_int64_value(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // bool bool_value = 2;
  private:
  bool _internal_has_bool_value() const;
  public:
  void clear_bool_value();
  bool bool_value() const;
  void set_bool_value(bool value);
  private:
  bool _internal_bool_value() const;
  void _internal_set_bool_value(bool value);
  public:

  // string string_value = 3;
  private:
  bool _internal_has_string_value() const;
  public:
  void clear_string_value();
  const std::string& string_value() const;
  void set_string_value(const std::string& value);
  void set_string_value(std::string&& value);
  void set_string_value(const char* value);
  void set_string_value(const char* value, size_t size);
  std::string* mutable_string_value();
  std::string* release_string_value();
  void set_allocated_string_value(std::string* string_value);
  private:
  const std::string& _internal_string_value() const;
  void _internal_set_string_value(const std::string& value);
  std::string* _internal_mutable_string_value();
  public:

  // bytes bytes_value = 4;
  private:
  bool _internal_has_bytes_value() const;
  public:
  void clear_bytes_value();
  const std::string& bytes_value() const;
  void set_bytes_value(const std::string& value);
  void set_bytes_value(std::string&& value);
  void set_bytes_value(const char* value);
  void set_bytes_value(const void* value, size_t size);
  std::string* mutable_bytes_value();
  std::string* release_bytes_value();
  void set_allocated_bytes_value(std::string* bytes_value);
  private:
  const std::string& _internal_bytes_value() const;
  void _internal_set_bytes_value(const std::string& value);
  std::string* _internal_mutable_bytes_value();
  public:

  // .signal_source_definition.DefaultSource default_signal = 5;
  bool has_default_signal() const;
  private:
  bool _internal_has_default_signal() const;
  public:
  void clear_default_signal();
  const ::signal_source_definition::DefaultSource& default_signal() const;
  ::signal_source_definition::DefaultSource* release_default_signal();
  ::signal_source_definition::DefaultSource* mutable_default_signal();
  void set_allocated_default_signal(::signal_source_definition::DefaultSource* default_signal);
  private:
  const ::signal_source_definition::DefaultSource& _internal_default_signal() const;
  ::signal_source_definition::DefaultSource* _internal_mutable_default_signal();
  public:

  // .signal_source_definition.CanSource can_signal = 6;
  bool has_can_signal() const;
  private:
  bool _internal_has_can_signal() const;
  public:
  void clear_can_signal();
  const ::signal_source_definition::CanSource& can_signal() const;
  ::signal_source_definition::CanSource* release_can_signal();
  ::signal_source_definition::CanSource* mutable_can_signal();
  void set_allocated_can_signal(::signal_source_definition::CanSource* can_signal);
  private:
  const ::signal_source_definition::CanSource& _internal_can_signal() const;
  ::signal_source_definition::CanSource* _internal_mutable_can_signal();
  public:

  // .signal_source_definition.LinSource lin_signal = 7;
  bool has_lin_signal() const;
  private:
  bool _internal_has_lin_signal() const;
  public:
  void clear_lin_signal();
  const ::signal_source_definition::LinSource& lin_signal() const;
  ::signal_source_definition::LinSource* release_lin_signal();
  ::signal_source_definition::LinSource* mutable_lin_signal();
  void set_allocated_lin_signal(::signal_source_definition::LinSource* lin_signal);
  private:
  const ::signal_source_definition::LinSource& _internal_lin_signal() const;
  ::signal_source_definition::LinSource* _internal_mutable_lin_signal();
  public:

  // .signal_source_definition.EthernetSource ethernet_signal = 8;
  bool has_ethernet_signal() const;
  private:
  bool _internal_has_ethernet_signal() const;
  public:
  void clear_ethernet_signal();
  const ::signal_source_definition::EthernetSource& ethernet_signal() const;
  ::signal_source_definition::EthernetSource* release_ethernet_signal();
  ::signal_source_definition::EthernetSource* mutable_ethernet_signal();
  void set_allocated_ethernet_signal(::signal_source_definition::EthernetSource* ethernet_signal);
  private:
  const ::signal_source_definition::EthernetSource& _internal_ethernet_signal() const;
  ::signal_source_definition::EthernetSource* _internal_mutable_ethernet_signal();
  public:

  // .signal_source_definition.NetworkSource network_signal = 9;
  bool has_network_signal() const;
  private:
  bool _internal_has_network_signal() const;
  public:
  void clear_network_signal();
  const ::signal_source_definition::NetworkSource& network_signal() const;
  ::signal_source_definition::NetworkSource* release_network_signal();
  ::signal_source_definition::NetworkSource* mutable_network_signal();
  void set_allocated_network_signal(::signal_source_definition::NetworkSource* network_signal);
  private:
  const ::signal_source_definition::NetworkSource& _internal_network_signal() const;
  ::signal_source_definition::NetworkSource* _internal_mutable_network_signal();
  public:

  // .signal_source_definition.InternalSource internal_signal = 10;
  bool has_internal_signal() const;
  private:
  bool _internal_has_internal_signal() const;
  public:
  void clear_internal_signal();
  const ::signal_source_definition::InternalSource& internal_signal() const;
  ::signal_source_definition::InternalSource* release_internal_signal();
  ::signal_source_definition::InternalSource* mutable_internal_signal();
  void set_allocated_internal_signal(::signal_source_definition::InternalSource* internal_signal);
  private:
  const ::signal_source_definition::InternalSource& _internal_internal_signal() const;
  ::signal_source_definition::InternalSource* _internal_mutable_internal_signal();
  public:

  // .signal_source_definition.ProcessingToolboxSource processing_toolbox_signal = 11;
  bool has_processing_toolbox_signal() const;
  private:
  bool _internal_has_processing_toolbox_signal() const;
  public:
  void clear_processing_toolbox_signal();
  const ::signal_source_definition::ProcessingToolboxSource& processing_toolbox_signal() const;
  ::signal_source_definition::ProcessingToolboxSource* release_processing_toolbox_signal();
  ::signal_source_definition::ProcessingToolboxSource* mutable_processing_toolbox_signal();
  void set_allocated_processing_toolbox_signal(::signal_source_definition::ProcessingToolboxSource* processing_toolbox_signal);
  private:
  const ::signal_source_definition::ProcessingToolboxSource& _internal_processing_toolbox_signal() const;
  ::signal_source_definition::ProcessingToolboxSource* _internal_mutable_processing_toolbox_signal();
  public:

  // .signal_source_definition.ThriftmeSource thriftme_signal = 12;
  bool has_thriftme_signal() const;
  private:
  bool _internal_has_thriftme_signal() const;
  public:
  void clear_thriftme_signal();
  const ::signal_source_definition::ThriftmeSource& thriftme_signal() const;
  ::signal_source_definition::ThriftmeSource* release_thriftme_signal();
  ::signal_source_definition::ThriftmeSource* mutable_thriftme_signal();
  void set_allocated_thriftme_signal(::signal_source_definition::ThriftmeSource* thriftme_signal);
  private:
  const ::signal_source_definition::ThriftmeSource& _internal_thriftme_signal() const;
  ::signal_source_definition::ThriftmeSource* _internal_mutable_thriftme_signal();
  public:

  void clear_operand();
  OperandCase operand_case() const;
  // @@protoc_insertion_point(class_scope:logical_expression.Operand)
 private:
  class _Internal;
  void set_has_int64_value();
  void set_has_bool_value();
  void set_has_string_value();
  void set_has_bytes_value();
  void set_has_default_signal();
  void set_has_can_signal();
  void set_has_lin_signal();
  void set_has_ethernet_signal();
  void set_has_network_signal();
  void set_has_internal_signal();
  void set_has_processing_toolbox_signal();
  void set_has_thriftme_signal();

  inline bool has_operand() const;
  inline void clear_has_operand();

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  union OperandUnion {
    OperandUnion() {}
    ::PROTOBUF_NAMESPACE_ID::int64 int64_value_;
    bool bool_value_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr string_value_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bytes_value_;
    ::signal_source_definition::DefaultSource* default_signal_;
    ::signal_source_definition::CanSource* can_signal_;
    ::signal_source_definition::LinSource* lin_signal_;
    ::signal_source_definition::EthernetSource* ethernet_signal_;
    ::signal_source_definition::NetworkSource* network_signal_;
    ::signal_source_definition::InternalSource* internal_signal_;
    ::signal_source_definition::ProcessingToolboxSource* processing_toolbox_signal_;
    ::signal_source_definition::ThriftmeSource* thriftme_signal_;
  } operand_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_logical_5fexpression_2eproto;
};
// -------------------------------------------------------------------

class ComparisonExpression :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:logical_expression.ComparisonExpression) */ {
 public:
  ComparisonExpression();
  virtual ~ComparisonExpression();

  ComparisonExpression(const ComparisonExpression& from);
  ComparisonExpression(ComparisonExpression&& from) noexcept
    : ComparisonExpression() {
    *this = ::std::move(from);
  }

  inline ComparisonExpression& operator=(const ComparisonExpression& from) {
    CopyFrom(from);
    return *this;
  }
  inline ComparisonExpression& operator=(ComparisonExpression&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ComparisonExpression& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ComparisonExpression* internal_default_instance() {
    return reinterpret_cast<const ComparisonExpression*>(
               &_ComparisonExpression_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ComparisonExpression& a, ComparisonExpression& b) {
    a.Swap(&b);
  }
  inline void Swap(ComparisonExpression* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ComparisonExpression* New() const final {
    return CreateMaybeMessage<ComparisonExpression>(nullptr);
  }

  ComparisonExpression* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ComparisonExpression>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ComparisonExpression& from);
  void MergeFrom(const ComparisonExpression& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ComparisonExpression* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "logical_expression.ComparisonExpression";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_logical_5fexpression_2eproto);
    return ::descriptor_table_logical_5fexpression_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFirstOperationFieldNumber = 2,
    kSecondOperationFieldNumber = 4,
    kNotFieldNumber = 1,
    kOperatorFieldNumber = 3,
  };
  // .logical_expression.Operation first_operation = 2;
  bool has_first_operation() const;
  private:
  bool _internal_has_first_operation() const;
  public:
  void clear_first_operation();
  const ::logical_expression::Operation& first_operation() const;
  ::logical_expression::Operation* release_first_operation();
  ::logical_expression::Operation* mutable_first_operation();
  void set_allocated_first_operation(::logical_expression::Operation* first_operation);
  private:
  const ::logical_expression::Operation& _internal_first_operation() const;
  ::logical_expression::Operation* _internal_mutable_first_operation();
  public:

  // .logical_expression.Operation second_operation = 4;
  bool has_second_operation() const;
  private:
  bool _internal_has_second_operation() const;
  public:
  void clear_second_operation();
  const ::logical_expression::Operation& second_operation() const;
  ::logical_expression::Operation* release_second_operation();
  ::logical_expression::Operation* mutable_second_operation();
  void set_allocated_second_operation(::logical_expression::Operation* second_operation);
  private:
  const ::logical_expression::Operation& _internal_second_operation() const;
  ::logical_expression::Operation* _internal_mutable_second_operation();
  public:

  // bool not = 1;
  void clear_not_();
  bool not_() const;
  void set_not_(bool value);
  private:
  bool _internal_not_() const;
  void _internal_set_not_(bool value);
  public:

  // .logical_expression.ComparisonOperatorType operator = 3;
  void clear_operator_();
  ::logical_expression::ComparisonOperatorType operator_() const;
  void set_operator_(::logical_expression::ComparisonOperatorType value);
  private:
  ::logical_expression::ComparisonOperatorType _internal_operator_() const;
  void _internal_set_operator_(::logical_expression::ComparisonOperatorType value);
  public:

  // @@protoc_insertion_point(class_scope:logical_expression.ComparisonExpression)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::logical_expression::Operation* first_operation_;
  ::logical_expression::Operation* second_operation_;
  bool not__;
  int operator__;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_logical_5fexpression_2eproto;
};
// -------------------------------------------------------------------

class Operation :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:logical_expression.Operation) */ {
 public:
  Operation();
  virtual ~Operation();

  Operation(const Operation& from);
  Operation(Operation&& from) noexcept
    : Operation() {
    *this = ::std::move(from);
  }

  inline Operation& operator=(const Operation& from) {
    CopyFrom(from);
    return *this;
  }
  inline Operation& operator=(Operation&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Operation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Operation* internal_default_instance() {
    return reinterpret_cast<const Operation*>(
               &_Operation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Operation& a, Operation& b) {
    a.Swap(&b);
  }
  inline void Swap(Operation* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Operation* New() const final {
    return CreateMaybeMessage<Operation>(nullptr);
  }

  Operation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Operation>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Operation& from);
  void MergeFrom(const Operation& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Operation* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "logical_expression.Operation";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_logical_5fexpression_2eproto);
    return ::descriptor_table_logical_5fexpression_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFirstOperandFieldNumber = 1,
    kSecondOperandFieldNumber = 3,
    kOperatorFieldNumber = 2,
  };
  // .logical_expression.Operand first_operand = 1;
  bool has_first_operand() const;
  private:
  bool _internal_has_first_operand() const;
  public:
  void clear_first_operand();
  const ::logical_expression::Operand& first_operand() const;
  ::logical_expression::Operand* release_first_operand();
  ::logical_expression::Operand* mutable_first_operand();
  void set_allocated_first_operand(::logical_expression::Operand* first_operand);
  private:
  const ::logical_expression::Operand& _internal_first_operand() const;
  ::logical_expression::Operand* _internal_mutable_first_operand();
  public:

  // .logical_expression.Operand second_operand = 3;
  bool has_second_operand() const;
  private:
  bool _internal_has_second_operand() const;
  public:
  void clear_second_operand();
  const ::logical_expression::Operand& second_operand() const;
  ::logical_expression::Operand* release_second_operand();
  ::logical_expression::Operand* mutable_second_operand();
  void set_allocated_second_operand(::logical_expression::Operand* second_operand);
  private:
  const ::logical_expression::Operand& _internal_second_operand() const;
  ::logical_expression::Operand* _internal_mutable_second_operand();
  public:

  // .logical_expression.OperationType operator = 2;
  void clear_operator_();
  ::logical_expression::OperationType operator_() const;
  void set_operator_(::logical_expression::OperationType value);
  private:
  ::logical_expression::OperationType _internal_operator_() const;
  void _internal_set_operator_(::logical_expression::OperationType value);
  public:

  // @@protoc_insertion_point(class_scope:logical_expression.Operation)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::logical_expression::Operand* first_operand_;
  ::logical_expression::Operand* second_operand_;
  int operator__;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_logical_5fexpression_2eproto;
};
// -------------------------------------------------------------------

class TransitionExpression :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:logical_expression.TransitionExpression) */ {
 public:
  TransitionExpression();
  virtual ~TransitionExpression();

  TransitionExpression(const TransitionExpression& from);
  TransitionExpression(TransitionExpression&& from) noexcept
    : TransitionExpression() {
    *this = ::std::move(from);
  }

  inline TransitionExpression& operator=(const TransitionExpression& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransitionExpression& operator=(TransitionExpression&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TransitionExpression& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TransitionExpression* internal_default_instance() {
    return reinterpret_cast<const TransitionExpression*>(
               &_TransitionExpression_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(TransitionExpression& a, TransitionExpression& b) {
    a.Swap(&b);
  }
  inline void Swap(TransitionExpression* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TransitionExpression* New() const final {
    return CreateMaybeMessage<TransitionExpression>(nullptr);
  }

  TransitionExpression* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TransitionExpression>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TransitionExpression& from);
  void MergeFrom(const TransitionExpression& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransitionExpression* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "logical_expression.TransitionExpression";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_logical_5fexpression_2eproto);
    return ::descriptor_table_logical_5fexpression_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSignalIdentifierFieldNumber = 1,
    kFromValueFieldNumber = 3,
    kToValueFieldNumber = 5,
    kFromOperatorFieldNumber = 2,
    kToOperatorFieldNumber = 4,
  };
  // .logical_expression.Operand signal_identifier = 1;
  bool has_signal_identifier() const;
  private:
  bool _internal_has_signal_identifier() const;
  public:
  void clear_signal_identifier();
  const ::logical_expression::Operand& signal_identifier() const;
  ::logical_expression::Operand* release_signal_identifier();
  ::logical_expression::Operand* mutable_signal_identifier();
  void set_allocated_signal_identifier(::logical_expression::Operand* signal_identifier);
  private:
  const ::logical_expression::Operand& _internal_signal_identifier() const;
  ::logical_expression::Operand* _internal_mutable_signal_identifier();
  public:

  // .logical_expression.Operand from_value = 3;
  bool has_from_value() const;
  private:
  bool _internal_has_from_value() const;
  public:
  void clear_from_value();
  const ::logical_expression::Operand& from_value() const;
  ::logical_expression::Operand* release_from_value();
  ::logical_expression::Operand* mutable_from_value();
  void set_allocated_from_value(::logical_expression::Operand* from_value);
  private:
  const ::logical_expression::Operand& _internal_from_value() const;
  ::logical_expression::Operand* _internal_mutable_from_value();
  public:

  // .logical_expression.Operand to_value = 5;
  bool has_to_value() const;
  private:
  bool _internal_has_to_value() const;
  public:
  void clear_to_value();
  const ::logical_expression::Operand& to_value() const;
  ::logical_expression::Operand* release_to_value();
  ::logical_expression::Operand* mutable_to_value();
  void set_allocated_to_value(::logical_expression::Operand* to_value);
  private:
  const ::logical_expression::Operand& _internal_to_value() const;
  ::logical_expression::Operand* _internal_mutable_to_value();
  public:

  // .logical_expression.ComparisonOperatorType from_operator = 2;
  void clear_from_operator();
  ::logical_expression::ComparisonOperatorType from_operator() const;
  void set_from_operator(::logical_expression::ComparisonOperatorType value);
  private:
  ::logical_expression::ComparisonOperatorType _internal_from_operator() const;
  void _internal_set_from_operator(::logical_expression::ComparisonOperatorType value);
  public:

  // .logical_expression.ComparisonOperatorType to_operator = 4;
  void clear_to_operator();
  ::logical_expression::ComparisonOperatorType to_operator() const;
  void set_to_operator(::logical_expression::ComparisonOperatorType value);
  private:
  ::logical_expression::ComparisonOperatorType _internal_to_operator() const;
  void _internal_set_to_operator(::logical_expression::ComparisonOperatorType value);
  public:

  // @@protoc_insertion_point(class_scope:logical_expression.TransitionExpression)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::logical_expression::Operand* signal_identifier_;
  ::logical_expression::Operand* from_value_;
  ::logical_expression::Operand* to_value_;
  int from_operator_;
  int to_operator_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_logical_5fexpression_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// LogicalExpression

// bool not = 1;
inline void LogicalExpression::clear_not_() {
  not__ = false;
}
inline bool LogicalExpression::_internal_not_() const {
  return not__;
}
inline bool LogicalExpression::not_() const {
  // @@protoc_insertion_point(field_get:logical_expression.LogicalExpression.not)
  return _internal_not_();
}
inline void LogicalExpression::_internal_set_not_(bool value) {
  
  not__ = value;
}
inline void LogicalExpression::set_not_(bool value) {
  _internal_set_not_(value);
  // @@protoc_insertion_point(field_set:logical_expression.LogicalExpression.not)
}

// .logical_expression.LogicalOperator operator = 2;
inline void LogicalExpression::clear_operator_() {
  operator__ = 0;
}
inline ::logical_expression::LogicalOperator LogicalExpression::_internal_operator_() const {
  return static_cast< ::logical_expression::LogicalOperator >(operator__);
}
inline ::logical_expression::LogicalOperator LogicalExpression::operator_() const {
  // @@protoc_insertion_point(field_get:logical_expression.LogicalExpression.operator)
  return _internal_operator_();
}
inline void LogicalExpression::_internal_set_operator_(::logical_expression::LogicalOperator value) {
  
  operator__ = value;
}
inline void LogicalExpression::set_operator_(::logical_expression::LogicalOperator value) {
  _internal_set_operator_(value);
  // @@protoc_insertion_point(field_set:logical_expression.LogicalExpression.operator)
}

// repeated .logical_expression.LogicalOperand operand = 3;
inline int LogicalExpression::_internal_operand_size() const {
  return operand_.size();
}
inline int LogicalExpression::operand_size() const {
  return _internal_operand_size();
}
inline void LogicalExpression::clear_operand() {
  operand_.Clear();
}
inline ::logical_expression::LogicalOperand* LogicalExpression::mutable_operand(int index) {
  // @@protoc_insertion_point(field_mutable:logical_expression.LogicalExpression.operand)
  return operand_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::logical_expression::LogicalOperand >*
LogicalExpression::mutable_operand() {
  // @@protoc_insertion_point(field_mutable_list:logical_expression.LogicalExpression.operand)
  return &operand_;
}
inline const ::logical_expression::LogicalOperand& LogicalExpression::_internal_operand(int index) const {
  return operand_.Get(index);
}
inline const ::logical_expression::LogicalOperand& LogicalExpression::operand(int index) const {
  // @@protoc_insertion_point(field_get:logical_expression.LogicalExpression.operand)
  return _internal_operand(index);
}
inline ::logical_expression::LogicalOperand* LogicalExpression::_internal_add_operand() {
  return operand_.Add();
}
inline ::logical_expression::LogicalOperand* LogicalExpression::add_operand() {
  // @@protoc_insertion_point(field_add:logical_expression.LogicalExpression.operand)
  return _internal_add_operand();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::logical_expression::LogicalOperand >&
LogicalExpression::operand() const {
  // @@protoc_insertion_point(field_list:logical_expression.LogicalExpression.operand)
  return operand_;
}

// -------------------------------------------------------------------

// LogicalOperand

// bool not = 1;
inline void LogicalOperand::clear_not_() {
  not__ = false;
}
inline bool LogicalOperand::_internal_not_() const {
  return not__;
}
inline bool LogicalOperand::not_() const {
  // @@protoc_insertion_point(field_get:logical_expression.LogicalOperand.not)
  return _internal_not_();
}
inline void LogicalOperand::_internal_set_not_(bool value) {
  
  not__ = value;
}
inline void LogicalOperand::set_not_(bool value) {
  _internal_set_not_(value);
  // @@protoc_insertion_point(field_set:logical_expression.LogicalOperand.not)
}

// .logical_expression.ComparisonExpression comparison_expression = 2;
inline bool LogicalOperand::_internal_has_comparison_expression() const {
  return expression_function_case() == kComparisonExpression;
}
inline bool LogicalOperand::has_comparison_expression() const {
  return _internal_has_comparison_expression();
}
inline void LogicalOperand::set_has_comparison_expression() {
  _oneof_case_[0] = kComparisonExpression;
}
inline void LogicalOperand::clear_comparison_expression() {
  if (_internal_has_comparison_expression()) {
    delete expression_function_.comparison_expression_;
    clear_has_expression_function();
  }
}
inline ::logical_expression::ComparisonExpression* LogicalOperand::release_comparison_expression() {
  // @@protoc_insertion_point(field_release:logical_expression.LogicalOperand.comparison_expression)
  if (_internal_has_comparison_expression()) {
    clear_has_expression_function();
      ::logical_expression::ComparisonExpression* temp = expression_function_.comparison_expression_;
    expression_function_.comparison_expression_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::logical_expression::ComparisonExpression& LogicalOperand::_internal_comparison_expression() const {
  return _internal_has_comparison_expression()
      ? *expression_function_.comparison_expression_
      : *reinterpret_cast< ::logical_expression::ComparisonExpression*>(&::logical_expression::_ComparisonExpression_default_instance_);
}
inline const ::logical_expression::ComparisonExpression& LogicalOperand::comparison_expression() const {
  // @@protoc_insertion_point(field_get:logical_expression.LogicalOperand.comparison_expression)
  return _internal_comparison_expression();
}
inline ::logical_expression::ComparisonExpression* LogicalOperand::_internal_mutable_comparison_expression() {
  if (!_internal_has_comparison_expression()) {
    clear_expression_function();
    set_has_comparison_expression();
    expression_function_.comparison_expression_ = CreateMaybeMessage< ::logical_expression::ComparisonExpression >(
        GetArenaNoVirtual());
  }
  return expression_function_.comparison_expression_;
}
inline ::logical_expression::ComparisonExpression* LogicalOperand::mutable_comparison_expression() {
  // @@protoc_insertion_point(field_mutable:logical_expression.LogicalOperand.comparison_expression)
  return _internal_mutable_comparison_expression();
}

// .logical_expression.TransitionExpression transition_expression = 3;
inline bool LogicalOperand::_internal_has_transition_expression() const {
  return expression_function_case() == kTransitionExpression;
}
inline bool LogicalOperand::has_transition_expression() const {
  return _internal_has_transition_expression();
}
inline void LogicalOperand::set_has_transition_expression() {
  _oneof_case_[0] = kTransitionExpression;
}
inline void LogicalOperand::clear_transition_expression() {
  if (_internal_has_transition_expression()) {
    delete expression_function_.transition_expression_;
    clear_has_expression_function();
  }
}
inline ::logical_expression::TransitionExpression* LogicalOperand::release_transition_expression() {
  // @@protoc_insertion_point(field_release:logical_expression.LogicalOperand.transition_expression)
  if (_internal_has_transition_expression()) {
    clear_has_expression_function();
      ::logical_expression::TransitionExpression* temp = expression_function_.transition_expression_;
    expression_function_.transition_expression_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::logical_expression::TransitionExpression& LogicalOperand::_internal_transition_expression() const {
  return _internal_has_transition_expression()
      ? *expression_function_.transition_expression_
      : *reinterpret_cast< ::logical_expression::TransitionExpression*>(&::logical_expression::_TransitionExpression_default_instance_);
}
inline const ::logical_expression::TransitionExpression& LogicalOperand::transition_expression() const {
  // @@protoc_insertion_point(field_get:logical_expression.LogicalOperand.transition_expression)
  return _internal_transition_expression();
}
inline ::logical_expression::TransitionExpression* LogicalOperand::_internal_mutable_transition_expression() {
  if (!_internal_has_transition_expression()) {
    clear_expression_function();
    set_has_transition_expression();
    expression_function_.transition_expression_ = CreateMaybeMessage< ::logical_expression::TransitionExpression >(
        GetArenaNoVirtual());
  }
  return expression_function_.transition_expression_;
}
inline ::logical_expression::TransitionExpression* LogicalOperand::mutable_transition_expression() {
  // @@protoc_insertion_point(field_mutable:logical_expression.LogicalOperand.transition_expression)
  return _internal_mutable_transition_expression();
}

inline bool LogicalOperand::has_expression_function() const {
  return expression_function_case() != EXPRESSION_FUNCTION_NOT_SET;
}
inline void LogicalOperand::clear_has_expression_function() {
  _oneof_case_[0] = EXPRESSION_FUNCTION_NOT_SET;
}
inline LogicalOperand::ExpressionFunctionCase LogicalOperand::expression_function_case() const {
  return LogicalOperand::ExpressionFunctionCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Operand

// int64 int64_value = 1;
inline bool Operand::_internal_has_int64_value() const {
  return operand_case() == kInt64Value;
}
inline void Operand::set_has_int64_value() {
  _oneof_case_[0] = kInt64Value;
}
inline void Operand::clear_int64_value() {
  if (_internal_has_int64_value()) {
    operand_.int64_value_ = PROTOBUF_LONGLONG(0);
    clear_has_operand();
  }
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Operand::_internal_int64_value() const {
  if (_internal_has_int64_value()) {
    return operand_.int64_value_;
  }
  return PROTOBUF_LONGLONG(0);
}
inline void Operand::_internal_set_int64_value(::PROTOBUF_NAMESPACE_ID::int64 value) {
  if (!_internal_has_int64_value()) {
    clear_operand();
    set_has_int64_value();
  }
  operand_.int64_value_ = value;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Operand::int64_value() const {
  // @@protoc_insertion_point(field_get:logical_expression.Operand.int64_value)
  return _internal_int64_value();
}
inline void Operand::set_int64_value(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_int64_value(value);
  // @@protoc_insertion_point(field_set:logical_expression.Operand.int64_value)
}

// bool bool_value = 2;
inline bool Operand::_internal_has_bool_value() const {
  return operand_case() == kBoolValue;
}
inline void Operand::set_has_bool_value() {
  _oneof_case_[0] = kBoolValue;
}
inline void Operand::clear_bool_value() {
  if (_internal_has_bool_value()) {
    operand_.bool_value_ = false;
    clear_has_operand();
  }
}
inline bool Operand::_internal_bool_value() const {
  if (_internal_has_bool_value()) {
    return operand_.bool_value_;
  }
  return false;
}
inline void Operand::_internal_set_bool_value(bool value) {
  if (!_internal_has_bool_value()) {
    clear_operand();
    set_has_bool_value();
  }
  operand_.bool_value_ = value;
}
inline bool Operand::bool_value() const {
  // @@protoc_insertion_point(field_get:logical_expression.Operand.bool_value)
  return _internal_bool_value();
}
inline void Operand::set_bool_value(bool value) {
  _internal_set_bool_value(value);
  // @@protoc_insertion_point(field_set:logical_expression.Operand.bool_value)
}

// string string_value = 3;
inline bool Operand::_internal_has_string_value() const {
  return operand_case() == kStringValue;
}
inline void Operand::set_has_string_value() {
  _oneof_case_[0] = kStringValue;
}
inline void Operand::clear_string_value() {
  if (_internal_has_string_value()) {
    operand_.string_value_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
    clear_has_operand();
  }
}
inline const std::string& Operand::string_value() const {
  // @@protoc_insertion_point(field_get:logical_expression.Operand.string_value)
  return _internal_string_value();
}
inline void Operand::set_string_value(const std::string& value) {
  _internal_set_string_value(value);
  // @@protoc_insertion_point(field_set:logical_expression.Operand.string_value)
}
inline std::string* Operand::mutable_string_value() {
  // @@protoc_insertion_point(field_mutable:logical_expression.Operand.string_value)
  return _internal_mutable_string_value();
}
inline const std::string& Operand::_internal_string_value() const {
  if (_internal_has_string_value()) {
    return operand_.string_value_.GetNoArena();
  }
  return *&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void Operand::_internal_set_string_value(const std::string& value) {
  if (!_internal_has_string_value()) {
    clear_operand();
    set_has_string_value();
    operand_.string_value_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  operand_.string_value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void Operand::set_string_value(std::string&& value) {
  // @@protoc_insertion_point(field_set:logical_expression.Operand.string_value)
  if (!_internal_has_string_value()) {
    clear_operand();
    set_has_string_value();
    operand_.string_value_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  operand_.string_value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:logical_expression.Operand.string_value)
}
inline void Operand::set_string_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  if (!_internal_has_string_value()) {
    clear_operand();
    set_has_string_value();
    operand_.string_value_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  operand_.string_value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:logical_expression.Operand.string_value)
}
inline void Operand::set_string_value(const char* value, size_t size) {
  if (!_internal_has_string_value()) {
    clear_operand();
    set_has_string_value();
    operand_.string_value_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  operand_.string_value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:logical_expression.Operand.string_value)
}
inline std::string* Operand::_internal_mutable_string_value() {
  if (!_internal_has_string_value()) {
    clear_operand();
    set_has_string_value();
    operand_.string_value_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return operand_.string_value_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Operand::release_string_value() {
  // @@protoc_insertion_point(field_release:logical_expression.Operand.string_value)
  if (_internal_has_string_value()) {
    clear_has_operand();
    return operand_.string_value_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  } else {
    return nullptr;
  }
}
inline void Operand::set_allocated_string_value(std::string* string_value) {
  if (has_operand()) {
    clear_operand();
  }
  if (string_value != nullptr) {
    set_has_string_value();
    operand_.string_value_.UnsafeSetDefault(string_value);
  }
  // @@protoc_insertion_point(field_set_allocated:logical_expression.Operand.string_value)
}

// bytes bytes_value = 4;
inline bool Operand::_internal_has_bytes_value() const {
  return operand_case() == kBytesValue;
}
inline void Operand::set_has_bytes_value() {
  _oneof_case_[0] = kBytesValue;
}
inline void Operand::clear_bytes_value() {
  if (_internal_has_bytes_value()) {
    operand_.bytes_value_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
    clear_has_operand();
  }
}
inline const std::string& Operand::bytes_value() const {
  // @@protoc_insertion_point(field_get:logical_expression.Operand.bytes_value)
  return _internal_bytes_value();
}
inline void Operand::set_bytes_value(const std::string& value) {
  _internal_set_bytes_value(value);
  // @@protoc_insertion_point(field_set:logical_expression.Operand.bytes_value)
}
inline std::string* Operand::mutable_bytes_value() {
  // @@protoc_insertion_point(field_mutable:logical_expression.Operand.bytes_value)
  return _internal_mutable_bytes_value();
}
inline const std::string& Operand::_internal_bytes_value() const {
  if (_internal_has_bytes_value()) {
    return operand_.bytes_value_.GetNoArena();
  }
  return *&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void Operand::_internal_set_bytes_value(const std::string& value) {
  if (!_internal_has_bytes_value()) {
    clear_operand();
    set_has_bytes_value();
    operand_.bytes_value_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  operand_.bytes_value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void Operand::set_bytes_value(std::string&& value) {
  // @@protoc_insertion_point(field_set:logical_expression.Operand.bytes_value)
  if (!_internal_has_bytes_value()) {
    clear_operand();
    set_has_bytes_value();
    operand_.bytes_value_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  operand_.bytes_value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:logical_expression.Operand.bytes_value)
}
inline void Operand::set_bytes_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  if (!_internal_has_bytes_value()) {
    clear_operand();
    set_has_bytes_value();
    operand_.bytes_value_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  operand_.bytes_value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:logical_expression.Operand.bytes_value)
}
inline void Operand::set_bytes_value(const void* value, size_t size) {
  if (!_internal_has_bytes_value()) {
    clear_operand();
    set_has_bytes_value();
    operand_.bytes_value_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  operand_.bytes_value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:logical_expression.Operand.bytes_value)
}
inline std::string* Operand::_internal_mutable_bytes_value() {
  if (!_internal_has_bytes_value()) {
    clear_operand();
    set_has_bytes_value();
    operand_.bytes_value_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return operand_.bytes_value_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Operand::release_bytes_value() {
  // @@protoc_insertion_point(field_release:logical_expression.Operand.bytes_value)
  if (_internal_has_bytes_value()) {
    clear_has_operand();
    return operand_.bytes_value_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  } else {
    return nullptr;
  }
}
inline void Operand::set_allocated_bytes_value(std::string* bytes_value) {
  if (has_operand()) {
    clear_operand();
  }
  if (bytes_value != nullptr) {
    set_has_bytes_value();
    operand_.bytes_value_.UnsafeSetDefault(bytes_value);
  }
  // @@protoc_insertion_point(field_set_allocated:logical_expression.Operand.bytes_value)
}

// .signal_source_definition.DefaultSource default_signal = 5;
inline bool Operand::_internal_has_default_signal() const {
  return operand_case() == kDefaultSignal;
}
inline bool Operand::has_default_signal() const {
  return _internal_has_default_signal();
}
inline void Operand::set_has_default_signal() {
  _oneof_case_[0] = kDefaultSignal;
}
inline ::signal_source_definition::DefaultSource* Operand::release_default_signal() {
  // @@protoc_insertion_point(field_release:logical_expression.Operand.default_signal)
  if (_internal_has_default_signal()) {
    clear_has_operand();
      ::signal_source_definition::DefaultSource* temp = operand_.default_signal_;
    operand_.default_signal_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::signal_source_definition::DefaultSource& Operand::_internal_default_signal() const {
  return _internal_has_default_signal()
      ? *operand_.default_signal_
      : *reinterpret_cast< ::signal_source_definition::DefaultSource*>(&::signal_source_definition::_DefaultSource_default_instance_);
}
inline const ::signal_source_definition::DefaultSource& Operand::default_signal() const {
  // @@protoc_insertion_point(field_get:logical_expression.Operand.default_signal)
  return _internal_default_signal();
}
inline ::signal_source_definition::DefaultSource* Operand::_internal_mutable_default_signal() {
  if (!_internal_has_default_signal()) {
    clear_operand();
    set_has_default_signal();
    operand_.default_signal_ = CreateMaybeMessage< ::signal_source_definition::DefaultSource >(
        GetArenaNoVirtual());
  }
  return operand_.default_signal_;
}
inline ::signal_source_definition::DefaultSource* Operand::mutable_default_signal() {
  // @@protoc_insertion_point(field_mutable:logical_expression.Operand.default_signal)
  return _internal_mutable_default_signal();
}

// .signal_source_definition.CanSource can_signal = 6;
inline bool Operand::_internal_has_can_signal() const {
  return operand_case() == kCanSignal;
}
inline bool Operand::has_can_signal() const {
  return _internal_has_can_signal();
}
inline void Operand::set_has_can_signal() {
  _oneof_case_[0] = kCanSignal;
}
inline ::signal_source_definition::CanSource* Operand::release_can_signal() {
  // @@protoc_insertion_point(field_release:logical_expression.Operand.can_signal)
  if (_internal_has_can_signal()) {
    clear_has_operand();
      ::signal_source_definition::CanSource* temp = operand_.can_signal_;
    operand_.can_signal_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::signal_source_definition::CanSource& Operand::_internal_can_signal() const {
  return _internal_has_can_signal()
      ? *operand_.can_signal_
      : *reinterpret_cast< ::signal_source_definition::CanSource*>(&::signal_source_definition::_CanSource_default_instance_);
}
inline const ::signal_source_definition::CanSource& Operand::can_signal() const {
  // @@protoc_insertion_point(field_get:logical_expression.Operand.can_signal)
  return _internal_can_signal();
}
inline ::signal_source_definition::CanSource* Operand::_internal_mutable_can_signal() {
  if (!_internal_has_can_signal()) {
    clear_operand();
    set_has_can_signal();
    operand_.can_signal_ = CreateMaybeMessage< ::signal_source_definition::CanSource >(
        GetArenaNoVirtual());
  }
  return operand_.can_signal_;
}
inline ::signal_source_definition::CanSource* Operand::mutable_can_signal() {
  // @@protoc_insertion_point(field_mutable:logical_expression.Operand.can_signal)
  return _internal_mutable_can_signal();
}

// .signal_source_definition.LinSource lin_signal = 7;
inline bool Operand::_internal_has_lin_signal() const {
  return operand_case() == kLinSignal;
}
inline bool Operand::has_lin_signal() const {
  return _internal_has_lin_signal();
}
inline void Operand::set_has_lin_signal() {
  _oneof_case_[0] = kLinSignal;
}
inline ::signal_source_definition::LinSource* Operand::release_lin_signal() {
  // @@protoc_insertion_point(field_release:logical_expression.Operand.lin_signal)
  if (_internal_has_lin_signal()) {
    clear_has_operand();
      ::signal_source_definition::LinSource* temp = operand_.lin_signal_;
    operand_.lin_signal_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::signal_source_definition::LinSource& Operand::_internal_lin_signal() const {
  return _internal_has_lin_signal()
      ? *operand_.lin_signal_
      : *reinterpret_cast< ::signal_source_definition::LinSource*>(&::signal_source_definition::_LinSource_default_instance_);
}
inline const ::signal_source_definition::LinSource& Operand::lin_signal() const {
  // @@protoc_insertion_point(field_get:logical_expression.Operand.lin_signal)
  return _internal_lin_signal();
}
inline ::signal_source_definition::LinSource* Operand::_internal_mutable_lin_signal() {
  if (!_internal_has_lin_signal()) {
    clear_operand();
    set_has_lin_signal();
    operand_.lin_signal_ = CreateMaybeMessage< ::signal_source_definition::LinSource >(
        GetArenaNoVirtual());
  }
  return operand_.lin_signal_;
}
inline ::signal_source_definition::LinSource* Operand::mutable_lin_signal() {
  // @@protoc_insertion_point(field_mutable:logical_expression.Operand.lin_signal)
  return _internal_mutable_lin_signal();
}

// .signal_source_definition.EthernetSource ethernet_signal = 8;
inline bool Operand::_internal_has_ethernet_signal() const {
  return operand_case() == kEthernetSignal;
}
inline bool Operand::has_ethernet_signal() const {
  return _internal_has_ethernet_signal();
}
inline void Operand::set_has_ethernet_signal() {
  _oneof_case_[0] = kEthernetSignal;
}
inline ::signal_source_definition::EthernetSource* Operand::release_ethernet_signal() {
  // @@protoc_insertion_point(field_release:logical_expression.Operand.ethernet_signal)
  if (_internal_has_ethernet_signal()) {
    clear_has_operand();
      ::signal_source_definition::EthernetSource* temp = operand_.ethernet_signal_;
    operand_.ethernet_signal_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::signal_source_definition::EthernetSource& Operand::_internal_ethernet_signal() const {
  return _internal_has_ethernet_signal()
      ? *operand_.ethernet_signal_
      : *reinterpret_cast< ::signal_source_definition::EthernetSource*>(&::signal_source_definition::_EthernetSource_default_instance_);
}
inline const ::signal_source_definition::EthernetSource& Operand::ethernet_signal() const {
  // @@protoc_insertion_point(field_get:logical_expression.Operand.ethernet_signal)
  return _internal_ethernet_signal();
}
inline ::signal_source_definition::EthernetSource* Operand::_internal_mutable_ethernet_signal() {
  if (!_internal_has_ethernet_signal()) {
    clear_operand();
    set_has_ethernet_signal();
    operand_.ethernet_signal_ = CreateMaybeMessage< ::signal_source_definition::EthernetSource >(
        GetArenaNoVirtual());
  }
  return operand_.ethernet_signal_;
}
inline ::signal_source_definition::EthernetSource* Operand::mutable_ethernet_signal() {
  // @@protoc_insertion_point(field_mutable:logical_expression.Operand.ethernet_signal)
  return _internal_mutable_ethernet_signal();
}

// .signal_source_definition.NetworkSource network_signal = 9;
inline bool Operand::_internal_has_network_signal() const {
  return operand_case() == kNetworkSignal;
}
inline bool Operand::has_network_signal() const {
  return _internal_has_network_signal();
}
inline void Operand::set_has_network_signal() {
  _oneof_case_[0] = kNetworkSignal;
}
inline ::signal_source_definition::NetworkSource* Operand::release_network_signal() {
  // @@protoc_insertion_point(field_release:logical_expression.Operand.network_signal)
  if (_internal_has_network_signal()) {
    clear_has_operand();
      ::signal_source_definition::NetworkSource* temp = operand_.network_signal_;
    operand_.network_signal_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::signal_source_definition::NetworkSource& Operand::_internal_network_signal() const {
  return _internal_has_network_signal()
      ? *operand_.network_signal_
      : *reinterpret_cast< ::signal_source_definition::NetworkSource*>(&::signal_source_definition::_NetworkSource_default_instance_);
}
inline const ::signal_source_definition::NetworkSource& Operand::network_signal() const {
  // @@protoc_insertion_point(field_get:logical_expression.Operand.network_signal)
  return _internal_network_signal();
}
inline ::signal_source_definition::NetworkSource* Operand::_internal_mutable_network_signal() {
  if (!_internal_has_network_signal()) {
    clear_operand();
    set_has_network_signal();
    operand_.network_signal_ = CreateMaybeMessage< ::signal_source_definition::NetworkSource >(
        GetArenaNoVirtual());
  }
  return operand_.network_signal_;
}
inline ::signal_source_definition::NetworkSource* Operand::mutable_network_signal() {
  // @@protoc_insertion_point(field_mutable:logical_expression.Operand.network_signal)
  return _internal_mutable_network_signal();
}

// .signal_source_definition.InternalSource internal_signal = 10;
inline bool Operand::_internal_has_internal_signal() const {
  return operand_case() == kInternalSignal;
}
inline bool Operand::has_internal_signal() const {
  return _internal_has_internal_signal();
}
inline void Operand::set_has_internal_signal() {
  _oneof_case_[0] = kInternalSignal;
}
inline ::signal_source_definition::InternalSource* Operand::release_internal_signal() {
  // @@protoc_insertion_point(field_release:logical_expression.Operand.internal_signal)
  if (_internal_has_internal_signal()) {
    clear_has_operand();
      ::signal_source_definition::InternalSource* temp = operand_.internal_signal_;
    operand_.internal_signal_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::signal_source_definition::InternalSource& Operand::_internal_internal_signal() const {
  return _internal_has_internal_signal()
      ? *operand_.internal_signal_
      : *reinterpret_cast< ::signal_source_definition::InternalSource*>(&::signal_source_definition::_InternalSource_default_instance_);
}
inline const ::signal_source_definition::InternalSource& Operand::internal_signal() const {
  // @@protoc_insertion_point(field_get:logical_expression.Operand.internal_signal)
  return _internal_internal_signal();
}
inline ::signal_source_definition::InternalSource* Operand::_internal_mutable_internal_signal() {
  if (!_internal_has_internal_signal()) {
    clear_operand();
    set_has_internal_signal();
    operand_.internal_signal_ = CreateMaybeMessage< ::signal_source_definition::InternalSource >(
        GetArenaNoVirtual());
  }
  return operand_.internal_signal_;
}
inline ::signal_source_definition::InternalSource* Operand::mutable_internal_signal() {
  // @@protoc_insertion_point(field_mutable:logical_expression.Operand.internal_signal)
  return _internal_mutable_internal_signal();
}

// .signal_source_definition.ProcessingToolboxSource processing_toolbox_signal = 11;
inline bool Operand::_internal_has_processing_toolbox_signal() const {
  return operand_case() == kProcessingToolboxSignal;
}
inline bool Operand::has_processing_toolbox_signal() const {
  return _internal_has_processing_toolbox_signal();
}
inline void Operand::set_has_processing_toolbox_signal() {
  _oneof_case_[0] = kProcessingToolboxSignal;
}
inline ::signal_source_definition::ProcessingToolboxSource* Operand::release_processing_toolbox_signal() {
  // @@protoc_insertion_point(field_release:logical_expression.Operand.processing_toolbox_signal)
  if (_internal_has_processing_toolbox_signal()) {
    clear_has_operand();
      ::signal_source_definition::ProcessingToolboxSource* temp = operand_.processing_toolbox_signal_;
    operand_.processing_toolbox_signal_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::signal_source_definition::ProcessingToolboxSource& Operand::_internal_processing_toolbox_signal() const {
  return _internal_has_processing_toolbox_signal()
      ? *operand_.processing_toolbox_signal_
      : *reinterpret_cast< ::signal_source_definition::ProcessingToolboxSource*>(&::signal_source_definition::_ProcessingToolboxSource_default_instance_);
}
inline const ::signal_source_definition::ProcessingToolboxSource& Operand::processing_toolbox_signal() const {
  // @@protoc_insertion_point(field_get:logical_expression.Operand.processing_toolbox_signal)
  return _internal_processing_toolbox_signal();
}
inline ::signal_source_definition::ProcessingToolboxSource* Operand::_internal_mutable_processing_toolbox_signal() {
  if (!_internal_has_processing_toolbox_signal()) {
    clear_operand();
    set_has_processing_toolbox_signal();
    operand_.processing_toolbox_signal_ = CreateMaybeMessage< ::signal_source_definition::ProcessingToolboxSource >(
        GetArenaNoVirtual());
  }
  return operand_.processing_toolbox_signal_;
}
inline ::signal_source_definition::ProcessingToolboxSource* Operand::mutable_processing_toolbox_signal() {
  // @@protoc_insertion_point(field_mutable:logical_expression.Operand.processing_toolbox_signal)
  return _internal_mutable_processing_toolbox_signal();
}

// .signal_source_definition.ThriftmeSource thriftme_signal = 12;
inline bool Operand::_internal_has_thriftme_signal() const {
  return operand_case() == kThriftmeSignal;
}
inline bool Operand::has_thriftme_signal() const {
  return _internal_has_thriftme_signal();
}
inline void Operand::set_has_thriftme_signal() {
  _oneof_case_[0] = kThriftmeSignal;
}
inline ::signal_source_definition::ThriftmeSource* Operand::release_thriftme_signal() {
  // @@protoc_insertion_point(field_release:logical_expression.Operand.thriftme_signal)
  if (_internal_has_thriftme_signal()) {
    clear_has_operand();
      ::signal_source_definition::ThriftmeSource* temp = operand_.thriftme_signal_;
    operand_.thriftme_signal_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::signal_source_definition::ThriftmeSource& Operand::_internal_thriftme_signal() const {
  return _internal_has_thriftme_signal()
      ? *operand_.thriftme_signal_
      : *reinterpret_cast< ::signal_source_definition::ThriftmeSource*>(&::signal_source_definition::_ThriftmeSource_default_instance_);
}
inline const ::signal_source_definition::ThriftmeSource& Operand::thriftme_signal() const {
  // @@protoc_insertion_point(field_get:logical_expression.Operand.thriftme_signal)
  return _internal_thriftme_signal();
}
inline ::signal_source_definition::ThriftmeSource* Operand::_internal_mutable_thriftme_signal() {
  if (!_internal_has_thriftme_signal()) {
    clear_operand();
    set_has_thriftme_signal();
    operand_.thriftme_signal_ = CreateMaybeMessage< ::signal_source_definition::ThriftmeSource >(
        GetArenaNoVirtual());
  }
  return operand_.thriftme_signal_;
}
inline ::signal_source_definition::ThriftmeSource* Operand::mutable_thriftme_signal() {
  // @@protoc_insertion_point(field_mutable:logical_expression.Operand.thriftme_signal)
  return _internal_mutable_thriftme_signal();
}

inline bool Operand::has_operand() const {
  return operand_case() != OPERAND_NOT_SET;
}
inline void Operand::clear_has_operand() {
  _oneof_case_[0] = OPERAND_NOT_SET;
}
inline Operand::OperandCase Operand::operand_case() const {
  return Operand::OperandCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ComparisonExpression

// bool not = 1;
inline void ComparisonExpression::clear_not_() {
  not__ = false;
}
inline bool ComparisonExpression::_internal_not_() const {
  return not__;
}
inline bool ComparisonExpression::not_() const {
  // @@protoc_insertion_point(field_get:logical_expression.ComparisonExpression.not)
  return _internal_not_();
}
inline void ComparisonExpression::_internal_set_not_(bool value) {
  
  not__ = value;
}
inline void ComparisonExpression::set_not_(bool value) {
  _internal_set_not_(value);
  // @@protoc_insertion_point(field_set:logical_expression.ComparisonExpression.not)
}

// .logical_expression.Operation first_operation = 2;
inline bool ComparisonExpression::_internal_has_first_operation() const {
  return this != internal_default_instance() && first_operation_ != nullptr;
}
inline bool ComparisonExpression::has_first_operation() const {
  return _internal_has_first_operation();
}
inline void ComparisonExpression::clear_first_operation() {
  if (GetArenaNoVirtual() == nullptr && first_operation_ != nullptr) {
    delete first_operation_;
  }
  first_operation_ = nullptr;
}
inline const ::logical_expression::Operation& ComparisonExpression::_internal_first_operation() const {
  const ::logical_expression::Operation* p = first_operation_;
  return p != nullptr ? *p : *reinterpret_cast<const ::logical_expression::Operation*>(
      &::logical_expression::_Operation_default_instance_);
}
inline const ::logical_expression::Operation& ComparisonExpression::first_operation() const {
  // @@protoc_insertion_point(field_get:logical_expression.ComparisonExpression.first_operation)
  return _internal_first_operation();
}
inline ::logical_expression::Operation* ComparisonExpression::release_first_operation() {
  // @@protoc_insertion_point(field_release:logical_expression.ComparisonExpression.first_operation)
  
  ::logical_expression::Operation* temp = first_operation_;
  first_operation_ = nullptr;
  return temp;
}
inline ::logical_expression::Operation* ComparisonExpression::_internal_mutable_first_operation() {
  
  if (first_operation_ == nullptr) {
    auto* p = CreateMaybeMessage<::logical_expression::Operation>(GetArenaNoVirtual());
    first_operation_ = p;
  }
  return first_operation_;
}
inline ::logical_expression::Operation* ComparisonExpression::mutable_first_operation() {
  // @@protoc_insertion_point(field_mutable:logical_expression.ComparisonExpression.first_operation)
  return _internal_mutable_first_operation();
}
inline void ComparisonExpression::set_allocated_first_operation(::logical_expression::Operation* first_operation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete first_operation_;
  }
  if (first_operation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      first_operation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, first_operation, submessage_arena);
    }
    
  } else {
    
  }
  first_operation_ = first_operation;
  // @@protoc_insertion_point(field_set_allocated:logical_expression.ComparisonExpression.first_operation)
}

// .logical_expression.ComparisonOperatorType operator = 3;
inline void ComparisonExpression::clear_operator_() {
  operator__ = 0;
}
inline ::logical_expression::ComparisonOperatorType ComparisonExpression::_internal_operator_() const {
  return static_cast< ::logical_expression::ComparisonOperatorType >(operator__);
}
inline ::logical_expression::ComparisonOperatorType ComparisonExpression::operator_() const {
  // @@protoc_insertion_point(field_get:logical_expression.ComparisonExpression.operator)
  return _internal_operator_();
}
inline void ComparisonExpression::_internal_set_operator_(::logical_expression::ComparisonOperatorType value) {
  
  operator__ = value;
}
inline void ComparisonExpression::set_operator_(::logical_expression::ComparisonOperatorType value) {
  _internal_set_operator_(value);
  // @@protoc_insertion_point(field_set:logical_expression.ComparisonExpression.operator)
}

// .logical_expression.Operation second_operation = 4;
inline bool ComparisonExpression::_internal_has_second_operation() const {
  return this != internal_default_instance() && second_operation_ != nullptr;
}
inline bool ComparisonExpression::has_second_operation() const {
  return _internal_has_second_operation();
}
inline void ComparisonExpression::clear_second_operation() {
  if (GetArenaNoVirtual() == nullptr && second_operation_ != nullptr) {
    delete second_operation_;
  }
  second_operation_ = nullptr;
}
inline const ::logical_expression::Operation& ComparisonExpression::_internal_second_operation() const {
  const ::logical_expression::Operation* p = second_operation_;
  return p != nullptr ? *p : *reinterpret_cast<const ::logical_expression::Operation*>(
      &::logical_expression::_Operation_default_instance_);
}
inline const ::logical_expression::Operation& ComparisonExpression::second_operation() const {
  // @@protoc_insertion_point(field_get:logical_expression.ComparisonExpression.second_operation)
  return _internal_second_operation();
}
inline ::logical_expression::Operation* ComparisonExpression::release_second_operation() {
  // @@protoc_insertion_point(field_release:logical_expression.ComparisonExpression.second_operation)
  
  ::logical_expression::Operation* temp = second_operation_;
  second_operation_ = nullptr;
  return temp;
}
inline ::logical_expression::Operation* ComparisonExpression::_internal_mutable_second_operation() {
  
  if (second_operation_ == nullptr) {
    auto* p = CreateMaybeMessage<::logical_expression::Operation>(GetArenaNoVirtual());
    second_operation_ = p;
  }
  return second_operation_;
}
inline ::logical_expression::Operation* ComparisonExpression::mutable_second_operation() {
  // @@protoc_insertion_point(field_mutable:logical_expression.ComparisonExpression.second_operation)
  return _internal_mutable_second_operation();
}
inline void ComparisonExpression::set_allocated_second_operation(::logical_expression::Operation* second_operation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete second_operation_;
  }
  if (second_operation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      second_operation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, second_operation, submessage_arena);
    }
    
  } else {
    
  }
  second_operation_ = second_operation;
  // @@protoc_insertion_point(field_set_allocated:logical_expression.ComparisonExpression.second_operation)
}

// -------------------------------------------------------------------

// Operation

// .logical_expression.Operand first_operand = 1;
inline bool Operation::_internal_has_first_operand() const {
  return this != internal_default_instance() && first_operand_ != nullptr;
}
inline bool Operation::has_first_operand() const {
  return _internal_has_first_operand();
}
inline void Operation::clear_first_operand() {
  if (GetArenaNoVirtual() == nullptr && first_operand_ != nullptr) {
    delete first_operand_;
  }
  first_operand_ = nullptr;
}
inline const ::logical_expression::Operand& Operation::_internal_first_operand() const {
  const ::logical_expression::Operand* p = first_operand_;
  return p != nullptr ? *p : *reinterpret_cast<const ::logical_expression::Operand*>(
      &::logical_expression::_Operand_default_instance_);
}
inline const ::logical_expression::Operand& Operation::first_operand() const {
  // @@protoc_insertion_point(field_get:logical_expression.Operation.first_operand)
  return _internal_first_operand();
}
inline ::logical_expression::Operand* Operation::release_first_operand() {
  // @@protoc_insertion_point(field_release:logical_expression.Operation.first_operand)
  
  ::logical_expression::Operand* temp = first_operand_;
  first_operand_ = nullptr;
  return temp;
}
inline ::logical_expression::Operand* Operation::_internal_mutable_first_operand() {
  
  if (first_operand_ == nullptr) {
    auto* p = CreateMaybeMessage<::logical_expression::Operand>(GetArenaNoVirtual());
    first_operand_ = p;
  }
  return first_operand_;
}
inline ::logical_expression::Operand* Operation::mutable_first_operand() {
  // @@protoc_insertion_point(field_mutable:logical_expression.Operation.first_operand)
  return _internal_mutable_first_operand();
}
inline void Operation::set_allocated_first_operand(::logical_expression::Operand* first_operand) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete first_operand_;
  }
  if (first_operand) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      first_operand = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, first_operand, submessage_arena);
    }
    
  } else {
    
  }
  first_operand_ = first_operand;
  // @@protoc_insertion_point(field_set_allocated:logical_expression.Operation.first_operand)
}

// .logical_expression.OperationType operator = 2;
inline void Operation::clear_operator_() {
  operator__ = 0;
}
inline ::logical_expression::OperationType Operation::_internal_operator_() const {
  return static_cast< ::logical_expression::OperationType >(operator__);
}
inline ::logical_expression::OperationType Operation::operator_() const {
  // @@protoc_insertion_point(field_get:logical_expression.Operation.operator)
  return _internal_operator_();
}
inline void Operation::_internal_set_operator_(::logical_expression::OperationType value) {
  
  operator__ = value;
}
inline void Operation::set_operator_(::logical_expression::OperationType value) {
  _internal_set_operator_(value);
  // @@protoc_insertion_point(field_set:logical_expression.Operation.operator)
}

// .logical_expression.Operand second_operand = 3;
inline bool Operation::_internal_has_second_operand() const {
  return this != internal_default_instance() && second_operand_ != nullptr;
}
inline bool Operation::has_second_operand() const {
  return _internal_has_second_operand();
}
inline void Operation::clear_second_operand() {
  if (GetArenaNoVirtual() == nullptr && second_operand_ != nullptr) {
    delete second_operand_;
  }
  second_operand_ = nullptr;
}
inline const ::logical_expression::Operand& Operation::_internal_second_operand() const {
  const ::logical_expression::Operand* p = second_operand_;
  return p != nullptr ? *p : *reinterpret_cast<const ::logical_expression::Operand*>(
      &::logical_expression::_Operand_default_instance_);
}
inline const ::logical_expression::Operand& Operation::second_operand() const {
  // @@protoc_insertion_point(field_get:logical_expression.Operation.second_operand)
  return _internal_second_operand();
}
inline ::logical_expression::Operand* Operation::release_second_operand() {
  // @@protoc_insertion_point(field_release:logical_expression.Operation.second_operand)
  
  ::logical_expression::Operand* temp = second_operand_;
  second_operand_ = nullptr;
  return temp;
}
inline ::logical_expression::Operand* Operation::_internal_mutable_second_operand() {
  
  if (second_operand_ == nullptr) {
    auto* p = CreateMaybeMessage<::logical_expression::Operand>(GetArenaNoVirtual());
    second_operand_ = p;
  }
  return second_operand_;
}
inline ::logical_expression::Operand* Operation::mutable_second_operand() {
  // @@protoc_insertion_point(field_mutable:logical_expression.Operation.second_operand)
  return _internal_mutable_second_operand();
}
inline void Operation::set_allocated_second_operand(::logical_expression::Operand* second_operand) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete second_operand_;
  }
  if (second_operand) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      second_operand = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, second_operand, submessage_arena);
    }
    
  } else {
    
  }
  second_operand_ = second_operand;
  // @@protoc_insertion_point(field_set_allocated:logical_expression.Operation.second_operand)
}

// -------------------------------------------------------------------

// TransitionExpression

// .logical_expression.Operand signal_identifier = 1;
inline bool TransitionExpression::_internal_has_signal_identifier() const {
  return this != internal_default_instance() && signal_identifier_ != nullptr;
}
inline bool TransitionExpression::has_signal_identifier() const {
  return _internal_has_signal_identifier();
}
inline void TransitionExpression::clear_signal_identifier() {
  if (GetArenaNoVirtual() == nullptr && signal_identifier_ != nullptr) {
    delete signal_identifier_;
  }
  signal_identifier_ = nullptr;
}
inline const ::logical_expression::Operand& TransitionExpression::_internal_signal_identifier() const {
  const ::logical_expression::Operand* p = signal_identifier_;
  return p != nullptr ? *p : *reinterpret_cast<const ::logical_expression::Operand*>(
      &::logical_expression::_Operand_default_instance_);
}
inline const ::logical_expression::Operand& TransitionExpression::signal_identifier() const {
  // @@protoc_insertion_point(field_get:logical_expression.TransitionExpression.signal_identifier)
  return _internal_signal_identifier();
}
inline ::logical_expression::Operand* TransitionExpression::release_signal_identifier() {
  // @@protoc_insertion_point(field_release:logical_expression.TransitionExpression.signal_identifier)
  
  ::logical_expression::Operand* temp = signal_identifier_;
  signal_identifier_ = nullptr;
  return temp;
}
inline ::logical_expression::Operand* TransitionExpression::_internal_mutable_signal_identifier() {
  
  if (signal_identifier_ == nullptr) {
    auto* p = CreateMaybeMessage<::logical_expression::Operand>(GetArenaNoVirtual());
    signal_identifier_ = p;
  }
  return signal_identifier_;
}
inline ::logical_expression::Operand* TransitionExpression::mutable_signal_identifier() {
  // @@protoc_insertion_point(field_mutable:logical_expression.TransitionExpression.signal_identifier)
  return _internal_mutable_signal_identifier();
}
inline void TransitionExpression::set_allocated_signal_identifier(::logical_expression::Operand* signal_identifier) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete signal_identifier_;
  }
  if (signal_identifier) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      signal_identifier = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, signal_identifier, submessage_arena);
    }
    
  } else {
    
  }
  signal_identifier_ = signal_identifier;
  // @@protoc_insertion_point(field_set_allocated:logical_expression.TransitionExpression.signal_identifier)
}

// .logical_expression.ComparisonOperatorType from_operator = 2;
inline void TransitionExpression::clear_from_operator() {
  from_operator_ = 0;
}
inline ::logical_expression::ComparisonOperatorType TransitionExpression::_internal_from_operator() const {
  return static_cast< ::logical_expression::ComparisonOperatorType >(from_operator_);
}
inline ::logical_expression::ComparisonOperatorType TransitionExpression::from_operator() const {
  // @@protoc_insertion_point(field_get:logical_expression.TransitionExpression.from_operator)
  return _internal_from_operator();
}
inline void TransitionExpression::_internal_set_from_operator(::logical_expression::ComparisonOperatorType value) {
  
  from_operator_ = value;
}
inline void TransitionExpression::set_from_operator(::logical_expression::ComparisonOperatorType value) {
  _internal_set_from_operator(value);
  // @@protoc_insertion_point(field_set:logical_expression.TransitionExpression.from_operator)
}

// .logical_expression.Operand from_value = 3;
inline bool TransitionExpression::_internal_has_from_value() const {
  return this != internal_default_instance() && from_value_ != nullptr;
}
inline bool TransitionExpression::has_from_value() const {
  return _internal_has_from_value();
}
inline void TransitionExpression::clear_from_value() {
  if (GetArenaNoVirtual() == nullptr && from_value_ != nullptr) {
    delete from_value_;
  }
  from_value_ = nullptr;
}
inline const ::logical_expression::Operand& TransitionExpression::_internal_from_value() const {
  const ::logical_expression::Operand* p = from_value_;
  return p != nullptr ? *p : *reinterpret_cast<const ::logical_expression::Operand*>(
      &::logical_expression::_Operand_default_instance_);
}
inline const ::logical_expression::Operand& TransitionExpression::from_value() const {
  // @@protoc_insertion_point(field_get:logical_expression.TransitionExpression.from_value)
  return _internal_from_value();
}
inline ::logical_expression::Operand* TransitionExpression::release_from_value() {
  // @@protoc_insertion_point(field_release:logical_expression.TransitionExpression.from_value)
  
  ::logical_expression::Operand* temp = from_value_;
  from_value_ = nullptr;
  return temp;
}
inline ::logical_expression::Operand* TransitionExpression::_internal_mutable_from_value() {
  
  if (from_value_ == nullptr) {
    auto* p = CreateMaybeMessage<::logical_expression::Operand>(GetArenaNoVirtual());
    from_value_ = p;
  }
  return from_value_;
}
inline ::logical_expression::Operand* TransitionExpression::mutable_from_value() {
  // @@protoc_insertion_point(field_mutable:logical_expression.TransitionExpression.from_value)
  return _internal_mutable_from_value();
}
inline void TransitionExpression::set_allocated_from_value(::logical_expression::Operand* from_value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete from_value_;
  }
  if (from_value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      from_value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, from_value, submessage_arena);
    }
    
  } else {
    
  }
  from_value_ = from_value;
  // @@protoc_insertion_point(field_set_allocated:logical_expression.TransitionExpression.from_value)
}

// .logical_expression.ComparisonOperatorType to_operator = 4;
inline void TransitionExpression::clear_to_operator() {
  to_operator_ = 0;
}
inline ::logical_expression::ComparisonOperatorType TransitionExpression::_internal_to_operator() const {
  return static_cast< ::logical_expression::ComparisonOperatorType >(to_operator_);
}
inline ::logical_expression::ComparisonOperatorType TransitionExpression::to_operator() const {
  // @@protoc_insertion_point(field_get:logical_expression.TransitionExpression.to_operator)
  return _internal_to_operator();
}
inline void TransitionExpression::_internal_set_to_operator(::logical_expression::ComparisonOperatorType value) {
  
  to_operator_ = value;
}
inline void TransitionExpression::set_to_operator(::logical_expression::ComparisonOperatorType value) {
  _internal_set_to_operator(value);
  // @@protoc_insertion_point(field_set:logical_expression.TransitionExpression.to_operator)
}

// .logical_expression.Operand to_value = 5;
inline bool TransitionExpression::_internal_has_to_value() const {
  return this != internal_default_instance() && to_value_ != nullptr;
}
inline bool TransitionExpression::has_to_value() const {
  return _internal_has_to_value();
}
inline void TransitionExpression::clear_to_value() {
  if (GetArenaNoVirtual() == nullptr && to_value_ != nullptr) {
    delete to_value_;
  }
  to_value_ = nullptr;
}
inline const ::logical_expression::Operand& TransitionExpression::_internal_to_value() const {
  const ::logical_expression::Operand* p = to_value_;
  return p != nullptr ? *p : *reinterpret_cast<const ::logical_expression::Operand*>(
      &::logical_expression::_Operand_default_instance_);
}
inline const ::logical_expression::Operand& TransitionExpression::to_value() const {
  // @@protoc_insertion_point(field_get:logical_expression.TransitionExpression.to_value)
  return _internal_to_value();
}
inline ::logical_expression::Operand* TransitionExpression::release_to_value() {
  // @@protoc_insertion_point(field_release:logical_expression.TransitionExpression.to_value)
  
  ::logical_expression::Operand* temp = to_value_;
  to_value_ = nullptr;
  return temp;
}
inline ::logical_expression::Operand* TransitionExpression::_internal_mutable_to_value() {
  
  if (to_value_ == nullptr) {
    auto* p = CreateMaybeMessage<::logical_expression::Operand>(GetArenaNoVirtual());
    to_value_ = p;
  }
  return to_value_;
}
inline ::logical_expression::Operand* TransitionExpression::mutable_to_value() {
  // @@protoc_insertion_point(field_mutable:logical_expression.TransitionExpression.to_value)
  return _internal_mutable_to_value();
}
inline void TransitionExpression::set_allocated_to_value(::logical_expression::Operand* to_value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete to_value_;
  }
  if (to_value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      to_value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, to_value, submessage_arena);
    }
    
  } else {
    
  }
  to_value_ = to_value;
  // @@protoc_insertion_point(field_set_allocated:logical_expression.TransitionExpression.to_value)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace logical_expression

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::logical_expression::LogicalOperator> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::logical_expression::LogicalOperator>() {
  return ::logical_expression::LogicalOperator_descriptor();
}
template <> struct is_proto_enum< ::logical_expression::OperationType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::logical_expression::OperationType>() {
  return ::logical_expression::OperationType_descriptor();
}
template <> struct is_proto_enum< ::logical_expression::ComparisonOperatorType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::logical_expression::ComparisonOperatorType>() {
  return ::logical_expression::ComparisonOperatorType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_logical_5fexpression_2eproto
